// Coffee // Coffee Shop Interactive Story
// A game where the player selects a barista and follows a branching dialogue path

// Global variables
let state = "selection"; // start with barista selection
let selectedBarista = "";
let currentQuestion = "";
let responseOptions = [];
let showBlankImage = false;
let responseImages = {// Handle mouse dragging for text selection
function mouseDragged() {
if (isTypingActive && dragStartPos !== -1) {
// Set selection mode to active
selectionInProgress = true;

// Get text dimensions
const optionFound = false;
let textX = 0;
let textY = 0;
let optionWidth = 0;
let textFontSize = 0;

// Find the text input option to get its position
for (let i = 0; i < responseOptions.length; i++) {
  if (responseOptions[i].startsWith("*make a type box")) {
    // We found the text input option, now calculate its position
    const blankImagePlacement = getImagePlacement();
    const maxOptionHeight = height * 0.18;
    const blankRightEdge = blankImagePlacement.x + blankImagePlacement.width;
    const remainingSpace = width - blankRightEdge;
    
    // Calculate option dimensions
    const originalWidth = responseImages[state === "pete" ? 'P_R4.Blank' : 'M_R6.Blank'].width;
    const originalHeight = responseImages[state === "pete" ? 'P_R4.Blank' : 'M_R6.Blank'].height;
    const imgHeight = Math.min(maxOptionHeight, height * 0.18);
    const imgWidth = (imgHeight / originalHeight) * originalWidth;
    
    // Calculate option position
    const optionSpacing = height * 0.02;
    const bottomMargin = optionSpacing;
    const startX = blankRightEdge + (remainingSpace / 2) - (imgWidth / 2);
    
    // Set text position values for calculations
    textX = startX + imgWidth * 0.15;
    optionWidth = imgWidth;
    textFontSize = imgHeight * 0.25;
    
    break;
  }
}

if (textX === 0) return; // If we didn't find the text input option

// Calculate cursor position based on mouse position
if (pixellariFont) {
  textFont(pixellariFont);
}
textSize(textFontSize);

// Find cursor position at mouse point
let newPosition = 0;

// If mouse is before text area, set to start
if (mouseX <= textX) {
  newPosition = 0;
} 
// If mouse is past text area, set to end
else if (mouseX >= textX + textWidth(userInput)) {
  newPosition = userInput.length;
}
// Otherwise, find closest character
else {
  for (let i = 0; i <= userInput.length; i++) {
    const currText = userInput.substring(0, i);
    const currWidth = textWidth(currText);
    
    if (mouseX < textX + currWidth) {
      // Choose the closer position
      newPosition = (mouseX - (textX + textWidth(userInput.substring(0, i-1))) < 
                   (textX + currWidth) - mouseX) 
        ? Math.max(0, i - 1) 
        : i;
      break;
    }
    
    // If we've reached the end, place cursor at the end
    if (i === userInput.length) {
      newPosition = userInput.length;
    }
  }
}

// Set cursor to new position
cursorPosition = newPosition;

// Update selection
selectionMode = 'drag';
selectionStart = Math.min(dragStartPos, newPosition);
selectionEnd = Math.max(dragStartPos, newPosition);

// Reset text settings
textSize(height * 0.025);
textFont('sans-serif');
}
}

// Handle mouse release event
function mouseReleased() {
// If we were selecting text, finalize the selection
if (isTypingActive && selectionInProgress) {
selectionInProgress = false;

// If start and end are the same, clear selection
if (selectionStart === selectionEnd) {
  selectionMode = 'none';
  selectionStart = -1;
  selectionEnd = -1;
}
}

// Reset drag start position
dragStartPos = -1;
}

// Handle key typed events for text input
function keyTyped() {
// Only handle typing when typing is active
if (isTypingActive) {
// Get the text width of the current input with the Pixellari font
if (pixellariFont) {
  textFont(pixellariFont);
  textSize(height * 0.25); // Match the increased font size used in drawTextInputOnBlank
}

// If there's a selection, replace it
if (selectionMode !== 'none') {
  // Delete selected text and insert new character
  userInput = userInput.substring(0, selectionStart) + key + userInput.substring(selectionEnd);
  cursorPosition = selectionStart + 1; // Move cursor after inserted character
  
  // Reset selection
  selectionMode = 'none';
  selectionStart = -1;
  selectionEnd = -1;
} else {
  // Only check character count, not width, to ensure users can type all 10 characters
  if (userInput.length < maxCharacters) {
    // Insert character at cursor position
    userInput = userInput.substring(0, cursorPosition) + key + userInput.substring(cursorPosition);
    cursorPosition++; // Move cursor after inserted character
  }
}

// Reset the font to default
textFont('sans-serif');

return false; // Prevent default behavior
}
return true; // Allow default behavior
}

// Handle complex key press events
function keyPressed() {
if (!isTypingActive) return true;

// Handle Enter key for form submission when checkmark is visible
if (keyCode === ENTER && checkmarkVisible) {
yourName = userInput;
userInput = "";
isTypingActive = false;
if (state === "pete") {
  handlePeteResponse("checkmark");
} else if (state === "meowchi") {
  handleMeowchiResponse("checkmark");
}
return false;
}

// Handle backspace or delete with selection
if (keyCode === BACKSPACE || keyCode === 46) { // BACKSPACE or DELETE
if (selectionMode !== 'none') {
  // Delete selected text
  userInput = userInput.substring(0, selectionStart) + userInput.substring(selectionEnd);
  cursorPosition = selectionStart;
  
  // Reset selection
  selectionMode = 'none';
  selectionStart = -1;
  selectionEnd = -1;
  
  return false;
}

// Existing backspace/delete logic for no selection
if (keyCode === BACKSPACE) {
  if (cursorPosition > 0) {
    userInput = userInput.substring(0, cursorPosition - 1) + userInput.substring(cursorPosition);
    cursorPosition--;
  }
  return false;
}

if (keyCode === 46) { // DELETE key
  if (cursorPosition < userInput.length) {
    userInput = userInput.substring(0, cursorPosition) + userInput.substring(cursorPosition + 1);
  }
  return false;
}
}

// Handle left arrow (keyCode 37)
if (keyCode === 37) { // LEFT_ARROW
if (cursorPosition > 0) {
  cursorPosition--;
  
  // If shift is held, modify selection
  if (keyIsDown(SHIFT)) {
    if (selectionMode === 'none') {
      // Start a new selection
      selectionMode = 'drag';
      dragStartPos = cursorPosition + 1;
      selectionStart = cursorPosition;
      selectionEnd = dragStartPos;
    } else {
      // Update existing selection
      if (cursorPosition < dragStartPos) {
        selectionStart = cursorPosition;
        selectionEnd = dragStartPos;
      } else {
        selectionStart = dragStartPos;
        selectionEnd = cursorPosition;
      }
    }
  } else {
    // Reset selection on arrow key press without shift
    selectionMode = 'none';
    selectionStart = -1;
    selectionEnd = -1;
  }
}
return false;
}

// Handle right arrow (keyCode 39)
if (keyCode === 39) { // RIGHT_ARROW
if (cursorPosition < userInput.length) {
  cursorPosition++;
  
  // If shift is held, modify selection
  if (keyIsDown(SHIFT)) {
    if (selectionMode === 'none') {
      // Start a new selection
      selectionMode = 'drag';
      dragStartPos = cursorPosition - 1;
      selectionStart = dragStartPos;
      selectionEnd = cursorPosition;
    } else {
      // Update existing selection
      if (cursorPosition > dragStartPos) {
        selectionStart = dragStartPos;
        selectionEnd = cursorPosition;
      } else {
        selectionStart = cursorPosition;
        selectionEnd = dragStartPos;
      }
    }
  } else {
    // Reset selection on arrow key press without shift
    selectionMode = 'none';
    selectionStart = -1;
    selectionEnd = -1;
  }
}
return false;
}

// Handle Ctrl+A to select all (keyCode 65 is 'A')
if (keyCode === 65 && keyIsDown(CONTROL)) {
selectionMode = 'all';
selectionStart = 0;
selectionEnd = userInput.length;
cursorPosition = userInput.length;
return false;
}

// Handle home key (keyCode 36)
if (keyCode === 36) { // HOME
cursorPosition = 0;

// If shift is held, modify selection
if (keyIsDown(SHIFT)) {
  if (selectionMode === 'none') {
    selectionMode = 'drag';
    dragStartPos = userInput.length;
  }
  selectionStart = 0;
  selectionEnd = dragStartPos;
} else {
  // Reset selection
  selectionMode = 'none';
  selectionStart = -1;
  selectionEnd = -1;
}
return false;
}

// Handle end key (keyCode 35)
if (keyCode === 35) { // END
cursorPosition = userInput.length;

// If shift is held, modify selection
if (keyIsDown(SHIFT)) {
  if (selectionMode === 'none') {
    selectionMode = 'drag';
    dragStartPos = 0;
  }
  selectionStart = dragStartPos;
  selectionEnd = userInput.length;
} else {
  // Reset selection
  selectionMode = 'none';
  selectionStart = -1;
  selectionEnd = -1;
}
return false;
}

return true; // Allow default behavior for other keys
}

// Start Pete's dialogue sequence
function startPeteDialogue() {
console.log("Starting Pete dialogue sequence");
showBlankImage = true;
isTypingActive = false;
userInput = "";
cursorPosition = 0;
cursorVisible = true;
lastCursorBlink = millis();

// Reset selection
selectionMode = 'none';
selectionStart = -1;
selectionEnd = -1;

// Start with Q1 after a short delay
setTimeout(() => {
currentQuestion = "Can I take your order please?";
responseOptions = ["P_R1.1"];
showOptions = false;
timerStarted = false;
repeatCount = 0;
}, 200);
}

// Handle Pete's dialogue responses
function handlePeteResponse(response) {
showOptions = false;
timerStarted = false;

// Dialogue flow handling using a state machine approach
const dialogueMap = {
"Can I take your order please?": {
  // First interaction with only one option
  oneOption: () => {
    peteOrderTime += 0.2;
    currentQuestion = "Can I take your order please?";
    responseOptions = ["P_R1.1", "R_YES", "R_NO"];
  },
  // After showing multiple options
  "1": () => {
    repeatCount++;
    if (repeatCount >= 2) {
      currentQuestion = "Okay then…NEXT CUSTOMER!";
      responseOptions = [];
      peteOrderTime = ORIGINAL_PETE_ORDER_TIME;
      repeatCount = 0;
    } else {
      peteOrderTime += 0.2;
      currentQuestion = "Can I take your order please?";
    }
  },
  "2": () => {
    repeatCount = 0;
    currentQuestion = "What can I get you?";
    responseOptions = ["P_R3.1", "P_R3.2", "P_R3.3"];
  },
  "3": () => {
    repeatCount = 0;
    currentQuestion = "Okay then…NEXT CUSTOMER!";
    responseOptions = [];
    peteOrderTime = ORIGINAL_PETE_ORDER_TIME;
  }
},
"What can I get you?": {
  "1": () => {
    currentQuestion = "Ya! What ……..?";
    responseOptions = [
      "*make a type box",
      "P_R4.2"
    ];
  },
  "2": () => {
    currentQuestion = "Ya! What ……..?";
    responseOptions = [
      "*make a type box",
      "P_R4.2"
    ];
  },
  "3": () => {
    currentQuestion = "Ya! What ……..?";
    responseOptions = [
      "*make a type box",
      "P_R4.2"
    ];
  },
  default: () => {
    currentQuestion = "Ya! What ……..?";
    responseOptions = [
      "*make a type box",
      "P_R4.2"
    ];
  }
},
"Ya! What ……..?": {
  "checkmark": () => {
    // Save name and show confirmation (Q5.1)
    currentQuestion = `${yourName} ok then`;
    responseOptions = [];
    
    // After a short delay, transition to final drink delivery (Q6)
    setTimeout(() => {
      currentQuestion = `${yourName} here's your drink.`;
    }, 1500);
  },
  "repeat": () => {
    // If "I didn't catch that" is selected, show angry Pete (Q5.2)
    currentQuestion = "YOUR NAME?!!!";
    responseOptions = [
      "*make a type box"
    ];
    showBlankImage = true;
  },
  "textbox": () => {
    // This is now handled in mousePressed
    console.log("Activating text input");
    isTypingActive = true;
  }
},
"YOUR NAME?!!!": {
  "checkmark": () => {
    // After entering name in the angry Pete screen, go directly to final screen
    currentQuestion = `${yourName} here's your drink.`;
    responseOptions = [];
  },
  "textbox": () => {
    // This is now handled in mousePressed
    console.log("Activating text input");
    isTypingActive = true;
  }
}
};

// Execute the appropriate dialogue flow
if (dialogueMap[currentQuestion]) {
if (responseOptions.length === 1 && dialogueMap[currentQuestion].oneOption) {
  dialogueMap[currentQuestion].oneOption();
} else if (dialogueMap[currentQuestion][response]) {
  dialogueMap[currentQuestion][response]();
} else if (dialogueMap[currentQuestion].default) {
  dialogueMap[currentQuestion].default();
}
}
}

// Start Meowchi's dialogue sequence
function startMeowchiDialogue() {
  console.log("Starting Meowchi dialogue sequence");
  showBlankImage = false;
  isTypingActive = false;
  userInput = "";
  cursorPosition = 0;
  cursorVisible = true;
  lastCursorBlink = millis();
  
  // Reset selection
  selectionMode = 'none';
  selectionStart = -1;
  selectionEnd = -1;
  
  // Reset Meowchi state
  meowOrderTime = 2;
  meowchiConfusedShown = false;
  meowchiConfusedTimer = 0;
  meowchiMustSelectFrench = false;
  meowchiDrinkSelectionMade = false;
  meowchiNameEntered = false;
  meowchiRepeatBlenderCount = 0;
  
  // Start with Q1
  setTimeout(() => {
    currentQuestion = "[In meowish] meow meow me-meow meow?";
    responseOptions = ["Pardon?", "Huh", "Meow..?"];
    showOptions = false;
    timerStarted = false;
  }, 200);
}

// Handle Meowchi's dialogue responses
function handleMeowchiResponse(response) {
  showOptions = false;
  timerStarted = false;
  
  // Meowchi dialogue flow
  if (currentQuestion === "[In meowish] meow meow me-meow meow?") {
    if (response === "1" || response === "2" || response === "3") {
      // Show confused face for 2 seconds then show question again
      meowchiConfusedShown = true;
      meowchiConfusedTimer = millis();
      setTimeout(() => {
        currentQuestion = "[In meowish] meow meow me-meow meow?";
        responseOptions = ["Translate Meowish", "French", "English"];
        meowchiMustSelectFrench = true;
      }, 2000);
    }
  }
  // Second question after confused face with French option
  else if (currentQuestion === "[In meowish] meow meow me-meow meow?" && meowchiMustSelectFrench) {
    if (response === "french") {
      currentQuestion = "Que voulez-vous boire ?";
      responseOptions = ["For here", "A drink"];
      meowchiMustSelectFrench = false;
    }
    // The other options are not clickable
  }
  // After selecting French
  else if (currentQuestion === "Que voulez-vous boire ?") {
    if (response === "forhere" || response === "drink") {
      currentQuestion = "D'accord.. Voulez-vous un verre?";
      responseOptions = ["Yes", "No"];
    }
  }
  // After asking if they want a glass
  else if (currentQuestion === "D'accord.. Voulez-vous un verre?") {
    if (response === "yes") {
      currentQuestion = "Quelle boisson veux-tu?";
      responseOptions = ["Whisker Matcha", "PURspresso", "Catnip Tea"];
    }
    else if (response === "no") {
      currentQuestion = "Oh d'accord alors…";
      responseOptions = [];
    }
  }
  // After asking what drink they want
  else if (currentQuestion === "Quelle boisson veux-tu?") {
    if (response === "matcha" || response === "purspresso" || response === "catnip") {
      meowchiDrinkSelectionMade = true;
      currentQuestion = "Compris. Puis-je avoir ton n-BLENDERRRR";
      responseOptions = ["*make a type box", "WHAT DID YOU SAY?"];
    }
  }
  // After blender interruption
  else if (currentQuestion === "Compris. Puis-je avoir ton n-BLENDERRRR") {
    if (response === "textbox") {
      isTypingActive = true;
    }
    else if (response === "whatsay") {
      currentQuestion = "… votre nom?";
      responseOptions = ["*make a type box"];
    }
    else if (response === "checkmark") {
      meowchiNameEntered = true;
      currentQuestion = `hmm… ${yourName}?`;
      responseOptions = [];
      
      // After a short delay, transition to final drink delivery
      setTimeout(() => {
        currentQuestion = `${yourName} votre boisson est prête`;
        responseOptions = [];
      }, 2000);
    }
  }
  // After asking for name again
  else if (currentQuestion === "… votre nom?") {
    if (response === "textbox") {
      isTypingActive = true;
    }
    else if (response === "checkmark") {
      meowchiNameEntered = true;
      currentQuestion = `hmm… ${yourName}?`;
      responseOptions = [];
      
      // After a short delay, transition to final drink delivery
      setTimeout(() => {
        currentQuestion = `${yourName} votre boisson est prête`;
        responseOptions = [];
      }, 2000);
    }
  }
}

// Render table scene
function drawTable() {
// Draw table background or fallback
if (tableBackground) {
image(tableBackground, 0, 0, width, height);
} else {
background(200, 230, 200);
text("At your table", width/2, height/2);
}

// Show return button after delay
if (!timerStarted) {
displayTimer = millis();
timerStarted = true;
}

if (millis() - displayTimer > 3000) {
fill(220);
rect(width/2 - 100, height - 80, 200, 50, 10);
fill(0);
text("Return to selection", width/2, height - 55);
}
}


// HTML setup script tags:
// <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
// <script src="coffee_shop_game.js"></script>;
let yourName = "";
let userInput = "";
let maxCharacters = 10;
let checkmarkVisible = false;
let displayTimer = 0;
let timerStarted = false;
let showOptions = false;
let repeatCount = 0;
let isTypingActive = false; // Flag to track if typing is active
let cursorPosition = 0; // Track cursor position within text
let lastCursorBlink = 0; // For cursor blinking
let cursorVisible = true; // For cursor blinking
const CURSOR_BLINK_RATE = 500; // Blink every 500ms
let pixellariFont; // Variable to store the Pixellari font

// Text selection variables
let selectionMode = 'none'; // 'none', 'word', 'all'
let selectionStart = -1;
let selectionEnd = -1;
let selectionInProgress = false; // Track if user is currently dragging to select text
let dragStartPos = -1; // Starting position for drag selection

// Time variables
const ORIGINAL_PETE_ORDER_TIME = 0.2;
let peteOrderTime = ORIGINAL_PETE_ORDER_TIME; // seconds for initial order question
let drinkOrderTime = 1; // seconds for drink order question
let rejectionTime = 4; // seconds for rejection message

// Image and background variables (will be populated in preload)
let tableBackground, peteBackground, peteQ1Image, peteBlankImage, peteQ3R2Image, peteQ3Image, 
    peteQ5_1Image, peteQ5_2Image, peteQ6Image, blankInputImage, checkmarkImage;

// Meowchi image variables
let meowchiBackground, meowQ1Image, meowBlankConfusedImage, meowQ3Image, meowQ4Image, 
    meowQ5_1Image, meowQ5_2Image, meowQ6Image, meowQ7_1Image, meowQ7_2Image, meowQ8Image;

// Meowchi state tracking
let meowOrderTime = 2; // seconds for initial meowish order question
let meowchiConfusedShown = false;
let meowchiConfusedTimer = 0;
let meowchiMustSelectFrench = false;
let meowchiDrinkSelectionMade = false;
let meowchiNameEntered = false;
let meowchiRepeatBlenderCount = 0;

// Image loading handling function
function loadGameImage(path, fallbackColor) {
  return loadImage(path,
    () => console.log(`${path} loaded successfully`),
    (err) => {
      console.error(`Failed to load ${path}:`, err);
      const img = createImage(400, 100);
      img.loadPixels();
      for (let i = 0; i < img.width; i++) {
        for (let j = 0; j < img.height; j++) {
          img.set(i, j, color(fallbackColor));
        }
      }
      img.updatePixels();
      return img;
    }
  );
}

// Helper function to ensure consistent image dimensions
function getImagePlacement() {
  const bottomMargin = height * 0.02;
  const imgWidth = width * 0.52;
  const imgHeight = width * 0.31;
  const imgX = width * 0.02;
  const imgY = height - imgHeight - bottomMargin;
  return { x: imgX, y: imgY, width: imgWidth, height: imgHeight };
}

// Preload function to load all necessary assets
function preload() {
  try {
    // Load font
    pixellariFont = loadFont('Pixellari.ttf');
    
    // Load table background (placeholder)
    tableBackground = loadImage('https://placehold.co/800x600');
    
    // Load Pete's background image
    peteBackground = loadGameImage('BG_pete.png', [220, 180, 140]);
    
    // Load Pete's dialogue images
    peteQ1Image = loadGameImage('P_Q1.png', [255, 200, 200]);
    peteBlankImage = loadGameImage('P_Blank.png', [200, 200, 255]);
    peteQ3R2Image = loadGameImage('P_Q3.R2.png', [255, 150, 150]);
    peteQ3Image = loadGameImage('P_Q3.png', [200, 255, 200]);
    peteQ5_1Image = loadGameImage('P_Q5.1.png', [220, 200, 255]); // Confused face
    peteQ5_2Image = loadGameImage('P_Q5.2.png', [255, 150, 150]); // Angry face YOUR NAME?!!!
    peteQ6Image = loadGameImage('P_Q6.png', [200, 220, 255]); // Tired face with drink
    
    // Load blank image for text input
    blankInputImage = loadGameImage('P_R4.Blank.png', [240, 240, 255]);
    checkmarkImage = loadGameImage('check.png', [100, 255, 100]);
    
    // Load response images
    const imageKeys = ['P_R1.1', 'R_NO', 'R_YES', 'P_R3.1', 'P_R3.2', 'P_R3.3', 'P_R4.2'];
    const fallbackColors = [
      [220, 220, 255], [255, 220, 220], [220, 255, 220], 
      [255, 220, 220], [220, 255, 220], [220, 220, 255], [200, 255, 255]
    ];
    
    // Load all response images
    for (let i = 0; i < imageKeys.length; i++) {
      responseImages[imageKeys[i]] = loadGameImage(`${imageKeys[i]}.png`, fallbackColors[i]);
    }
    
    // Add the blank response image to responseImages collection
    responseImages['P_R4.Blank'] = blankInputImage;
    
    // Load Meowchi's background image
    meowchiBackground = loadGameImage('BG_meowchi.png', [220, 240, 220]);
    
    // Load Meowchi's dialogue images
    meowQ1Image = loadGameImage('M_Q1.png', [240, 220, 255]);
    meowBlankConfusedImage = loadGameImage('M_Blank.confused.png', [255, 220, 220]);
    meowQ3Image = loadGameImage('M_Q3.png', [220, 240, 255]);
    meowQ4Image = loadGameImage('M_Q4.png', [240, 255, 220]);
    meowQ5_1Image = loadGameImage('M_Q5.1.png', [255, 230, 230]);
    meowQ5_2Image = loadGameImage('M_Q5.2.png', [230, 255, 230]);
    meowQ6Image = loadGameImage('M_Q6.png', [230, 230, 255]); 
    meowQ7_1Image = loadGameImage('M_Q7.1.png', [255, 240, 220]);
    meowQ7_2Image = loadGameImage('M_Q7.2.png', [220, 255, 240]);
    meowQ8Image = loadGameImage('M_Q8.png', [240, 220, 255]);
    
    // Load response images for Meowchi
    responseImages['M_R1.1'] = loadGameImage('M_R1.1.png', [255, 220, 220]);
    responseImages['M_R1.2'] = loadGameImage('M_R1.2.png', [220, 255, 220]);
    responseImages['M_R1.3'] = loadGameImage('M_R1.3.png', [220, 220, 255]);
    responseImages['M_R2.1'] = loadGameImage('M_R2.1.png', [255, 230, 230]);
    responseImages['M_R2.2'] = loadGameImage('M_R2.2.png', [230, 255, 230]);
    responseImages['M_R2.3'] = loadGameImage('M_R2.3.png', [230, 230, 255]);
    responseImages['M_R3.1'] = loadGameImage('M_R3.1.png', [255, 240, 220]);
    responseImages['M_R3.2'] = loadGameImage('M_R3.2.png', [220, 255, 240]);
    responseImages['M_R5.1'] = loadGameImage('M_R5.1.png', [240, 220, 255]);
    responseImages['M_R5.2'] = loadGameImage('M_R5.2.png', [220, 240, 255]);
    responseImages['M_R5.3'] = loadGameImage('M_R5.3.png', [240, 255, 220]);
    responseImages['M_R6'] = loadGameImage('M_R6.png', [255, 220, 240]);
    responseImages['M_R6.Blank'] = loadGameImage('M_R6.Blank.png', [240, 240, 255]);
    responseImages['M_YES'] = loadGameImage('M_YES.png', [220, 255, 220]);
    responseImages['M_NO'] = loadGameImage('M_NO.png', [255, 220, 220]);
    
  } catch (e) {
    console.error('Error loading images:', e);
  }
}

// Setup function to initialize the canvas and game settings
function setup() {
  try {
    // Calculate canvas dimensions with correct aspect ratio
    const targetWidth = 1280;
    const aspectRatio = 16/9;
    createCanvas(targetWidth, targetWidth / aspectRatio);
    textAlign(CENTER, CENTER);
    textSize(height * 0.02);
    
    // Use default font as fallback if Pixellari doesn't load properly
    if (!pixellariFont) {
      console.warn("Pixellari font not loaded, using default font instead");
    }
  } catch (e) {
    console.error('Error in setup:', e);
  }
}

// Main draw function to render different game states
function draw() {
  try {
    // Only use default background for states other than pete
    if (state !== "pete") {
      background(220);
    }
    
    switch(state) {
      case "selection":
        drawBaristaSelection();
        showBlankImage = false;
        break;
      case "pete":
        drawPeteScene();
        break;
      case "meowchi":
        drawMeowchiDialogue();
        showBlankImage = false;
        break;
      case "table":
        drawTable();
        showBlankImage = false;
        break;
      default:
        state = "selection";
        showBlankImage = false;
        break;
    }
  } catch (e) {
    console.error('Error in draw:', e);
    background(255, 0, 0);
    fill(255);
    text('An error occurred. Please check console.', width/2, height/2);
  }
}

// Draw the barista selection screen
function drawBaristaSelection() {
  background(240);
  fill(0);
  textSize(width / 30);
  text("Pick a barista", width/2, height/8);
  
  const buttonWidth = width/5;
  const buttonHeight = height/6;
  const positions = [
    { x: width/4, y: height/2, label: "Pete" },
    { x: 3*width/4, y: height/2, label: "Meowchi" }
  ];
  
  // Draw both buttons
  for (const pos of positions) {
    fill(220);
    rect(pos.x - buttonWidth/2, pos.y - buttonHeight/2, buttonWidth, buttonHeight, 15);
    fill(0);
    text(pos.label, pos.x, pos.y);
  }
}

// Draw the Pete dialogue scene
function drawPeteScene() {
  // Draw the Pete background image for all parts of the Pete sequence
  if (peteBackground) {
    // Draw background to fill the entire canvas
    image(peteBackground, 0, 0, width, height);
  }
  
  // Handle image selection: blank background or dialogue
  if (showBlankImage && peteBlankImage) {
    const placement = getImagePlacement();
    image(peteBlankImage, placement.x, placement.y, placement.width, placement.height);
  }
  drawPeteDialogue();
}

// Render Pete's dialogue and manage dialogue progression
function drawPeteDialogue() {
  if (currentQuestion && !showOptions) {
    if (!timerStarted) {
      displayTimer = millis();
      timerStarted = true;
    }
    
    // Map questions to images and draw appropriately
    const questionImageMap = {
      "Can I take your order please?": peteQ1Image,
      "Okay then…NEXT CUSTOMER!": peteQ3R2Image,
      "What can I get you?": peteQ3Image,
      "Ya! What ……..?": peteBlankImage, // Using blank image for now, would be video
      "YOUR NAME?!!!": peteQ5_2Image,
      "here's your drink.": peteQ6Image
    };
    
    // Handle special case for name confirmation (Q5.1)
    if (currentQuestion.includes("ok then") && !currentQuestion.includes("here's your drink")) {
      const placement = getImagePlacement();
      image(peteQ5_1Image, placement.x, placement.y, placement.width, placement.height);
      
      // Display the entered name on top of the image in green with a question mark in black
      if (pixellariFont) {
        textFont(pixellariFont);
      }
      
      // Adjust text size to exactly 27% of option height
      const maxOptionHeight = height * 0.18;
      const fontSize = maxOptionHeight * 0.27;
      
      // Position further to the left (11% of image width) and keep vertical position
      const textX = placement.x + placement.width * 0.11;
      const textY = placement.y + placement.height * 0.62;
      
      textSize(fontSize);
      textAlign(LEFT, CENTER);
      
      // Calculate the total width of name and question mark
      const nameWidth = textWidth(yourName);
      const questionMarkWidth = textWidth("?");
      
      // Draw the name in the specified green (#80C242)
      fill('#80C242');
      text(yourName, textX, textY);
      
      // Draw the question mark in black, immediately after the name with slight spacing
      fill(0); // Black color for question mark
      text("?", textX + nameWidth + (fontSize * 0.1), textY);
      
      // Reset text settings
      textAlign(CENTER, CENTER);
      textSize(height * 0.02);
      textFont('sans-serif');
    }
    // Handle special case for final drink delivery (Q6)
    else if (currentQuestion.includes("here's your drink")) {
      const placement = getImagePlacement();
      image(peteQ6Image, placement.x, placement.y, placement.width, placement.height);
      
      // Display the entered name on top of the image in green followed by a black comma
      if (pixellariFont) {
        textFont(pixellariFont);
      }
      
      // Use the same formatting as in Q5.1
      const maxOptionHeight = height * 0.18;
      const fontSize = maxOptionHeight * 0.27;
      const textX = placement.x + placement.width * 0.11;
      const textY = placement.y + placement.height * 0.62;
      
      textSize(fontSize);
      textAlign(LEFT, CENTER);
      
      // Calculate the width of the name for positioning the comma
      const nameWidth = textWidth(yourName);
      
      // Draw the name in the specified green (#80C242)
      fill('#80C242');
      text(yourName, textX, textY);
      
      // Draw the comma in black, immediately after the name with slight spacing
      fill(0); // Black color for comma
      text(",", textX + nameWidth + (fontSize * 0.05), textY);
      
      // Reset text settings
      textAlign(CENTER, CENTER);
      textSize(height * 0.02);
      textFont('sans-serif');
    }
    else if (questionImageMap[currentQuestion]) {
      // Use consistent image placement
      const placement = getImagePlacement();
      image(questionImageMap[currentQuestion], placement.x, placement.y, placement.width, placement.height);
    } else {
      // For other questions, display text
      fill(255);
      rect(width/2 - 300, 50, 600, 100, 20);
      fill(0);
      text(currentQuestion, width/2, 100);
    }
    
    // Determine display time based on question type
    let displayTime = 2000; // Default
    
    if (state === "pete") {
      if (currentQuestion === "Can I take your order please?") {
        displayTime = peteOrderTime * 1000;
      } else if (currentQuestion === "What can I get you?" || currentQuestion === "Ya! What ……..?") {
        displayTime = drinkOrderTime * 1000; 
      } else if (currentQuestion.includes("NEXT CUSTOMER")) {
        displayTime = rejectionTime * 1000;
      } else if (currentQuestion.includes("here's your drink")) {
        displayTime = drinkOrderTime * 5000; // 5 seconds for final drink delivery as specified
      } else if (currentQuestion.includes("ok then")) {
        displayTime = drinkOrderTime * 2000; // Short pause for name confirmation before moving to final screen
      }
    }
    
    // Check if time is up
    if (millis() - displayTimer > displayTime) {
      showOptions = true;
      timerStarted = false;
      
      // Handle special cases that transition to table state
      if (currentQuestion.includes("NEXT CUSTOMER") || currentQuestion.includes("here's your drink")) {
        state = "table";
        showOptions = false;
        currentQuestion = "";
        responseOptions = [];
      }
    }
  }
  
  // Show response options when needed
  if (showOptions) {
    drawResponseOptions();
  }
}

// Render Meowchi dialogue
function drawMeowchiDialogue() {
  // Draw the Meowchi background image
  if (meowchiBackground) {
    image(meowchiBackground, 0, 0, width, height);
  } else {
    background(220, 240, 220);
  }
  
  // Handle image selection and dialogue progression
  if (currentQuestion && !showOptions) {
    if (!timerStarted) {
      displayTimer = millis();
      timerStarted = true;
    }
    
    // Map questions to images and draw appropriately
    const questionImageMap = {
      "[In meowish] meow meow me-meow meow?": meowQ1Image,
      "Que voulez-vous boire ?": meowQ3Image,
      "D'accord.. Voulez-vous un verre?": meowQ4Image,
      "Oh d'accord alors…": meowQ5_1Image,
      "Quelle boisson veux-tu?": meowQ5_2Image,
      "Compris. Puis-je avoir ton n-BLENDERRRR": meowQ6Image,
      "… votre nom?": meowQ7_2Image
    };
    
    // Handle showing the confused face between questions
    if (meowchiConfusedShown && millis() - meowchiConfusedTimer < 2000) {
      const placement = getImagePlacement();
      image(meowBlankConfusedImage, placement.x, placement.y, placement.width, placement.height);
    }
    // After the confused face timer is up, show the question again
    else if (meowchiConfusedShown) {
      meowchiConfusedShown = false;
      showOptions = true; // Show options again after confused face
    }
    // Special case for name confirmation (hmm... "yourName"?)
    else if (currentQuestion.includes("hmm…") && currentQuestion.includes(yourName)) {
      const placement = getImagePlacement();
      image(meowQ7_1Image, placement.x, placement.y, placement.width, placement.height);
      
      // Display the entered name on top of the image in green with a question mark
      if (pixellariFont) {
        textFont(pixellariFont);
      }
      
      // Use similar formatting to Pete's sequence
      const maxOptionHeight = height * 0.18;
      const fontSize = maxOptionHeight * 0.27;
      const textX = placement.x + placement.width * 0.11;
      const textY = placement.y + placement.height * 0.62;
      
      textSize(fontSize);
      textAlign(LEFT, CENTER);
      
      // Draw the name in green
      fill('#80C242');
      text(yourName, textX, textY);
      
      // Draw the question mark in black
      fill(0);
      text("?", textX + textWidth(yourName) + (fontSize * 0.1), textY);
      
      // Reset text settings
      textAlign(CENTER, CENTER);
      textSize(height * 0.02);
      textFont('sans-serif');
    }
    // Special case for final drink delivery
    else if (currentQuestion.includes("votre boisson est prête") && currentQuestion.includes(yourName)) {
      const placement = getImagePlacement();
      image(meowQ8Image, placement.x, placement.y, placement.width, placement.height);
      
      // Display the entered name on top of the image
      if (pixellariFont) {
        textFont(pixellariFont);
      }
      
      // Use similar formatting to Pete's sequence
      const maxOptionHeight = height * 0.18;
      const fontSize = maxOptionHeight * 0.27;
      const textX = placement.x + placement.width * 0.11;
      const textY = placement.y + placement.height * 0.62;
      
      textSize(fontSize);
      textAlign(LEFT, CENTER);
      
      // Draw the name in green
      fill('#80C242');
      text(yourName, textX, textY);
      
      // Reset text settings
      textAlign(CENTER, CENTER);
      textSize(height * 0.02);
      textFont('sans-serif');
    }
    else if (questionImageMap[currentQuestion]) {
      // Use consistent image placement
      const placement = getImagePlacement();
      image(questionImageMap[currentQuestion], placement.x, placement.y, placement.width, placement.height);
    } else {
      // For other questions, display text
      fill(255);
      rect(width/2 - 300, 50, 600, 100, 20);
      fill(0);
      text(currentQuestion, width/2, 100);
    }
    
    // Determine display time based on question type
    let displayTime = 2000; // Default
    
    if (state === "meowchi") {
      if (currentQuestion === "[In meowish] meow meow me-meow meow?") {
        displayTime = meowOrderTime * 1000;
      } else if (currentQuestion === "Oh d'accord alors…") {
        displayTime = 3000; // 3 seconds for rejection message
      } else if (currentQuestion.includes("votre boisson est prête")) {
        displayTime = 4000; // 4 seconds for final drink delivery
      } else if (currentQuestion.includes("hmm…")) {
        displayTime = 2000; // 2 seconds for name confirmation
      } else {
        displayTime = 2000; // 2 seconds for other questions
      }
    }
    
    // Check if time is up
    if (millis() - displayTimer > displayTime) {
      showOptions = true;
      timerStarted = false;
      
      // Handle special cases that transition to table state
      if (currentQuestion === "Oh d'accord alors…") {
        state = "selection";
        showOptions = false;
        currentQuestion = "";
        responseOptions = [];
      } else if (currentQuestion.includes("votre boisson est prête")) {
        state = "table";
        showOptions = false;
        currentQuestion = "";
        responseOptions = [];
      }
    }
  }
  
  // Show response options when needed
  if (showOptions) {
    drawResponseOptions();
  }
}

// Render response options for dialogues
function drawResponseOptions() {
  if (responseOptions.length === 0) return;

  const blankImagePlacement = getImagePlacement();
  const maxOptionHeight = height * 0.18;
  const blankRightEdge = blankImagePlacement.x + blankImagePlacement.width;
  const remainingSpace = width - blankRightEdge;
  const optionSpacing = height * 0.02;
  const bottomMargin = optionSpacing;
  
  // Process options to get their details (image keys, dimensions)
  let optionDetails = [];
  
  // Map text descriptions to image keys
  const textToImageMap = {
    "P_R1.1": "P_R1.1",
    "1. Can you repeat that please?": "P_R1.1",
    "No?": "R_NO",
    "3. No?": "R_NO",
    "Yea?": "R_YES",
    "2. Yea?": "R_YES",
    "1. Slow matcha?": "P_R3.1",
    "2. Bamboo tea?": "P_R3.2",
    "3. Black Eye espresso?": "P_R3.3",
    "I didn't catch that": "P_R4.2",
    "I didn't catch that, can you repeat?": "P_R4.2",
    "P_R4.2": "P_R4.2",
    "*make a type box": "P_R4.Blank",
    "Pardon?": "M_R1.1",
    "Huh": "M_R1.2",
    "Meow..?": "M_R1.3",
    "Translate Meowish": "M_R2.1",
    "French": "M_R2.2",
    "English": "M_R2.3",
    "For here": "M_R3.1",
    "A drink": "M_R3.2",
    "Yes": "M_YES",
    "No": "M_NO",
    "Whisker Matcha": "M_R5.1",
    "PURspresso": "M_R5.2", 
    "Catnip Tea": "M_R5.3",
    "WHAT DID YOU SAY?": "M_R6",
    "*make a type box": "M_R6.Blank"": "M_R2.2",
    "English": "M_R2.3",
    "For here": "M_R3.1",
    "A drink": "M_R3.2",
    "Yes": "M_YES",
    "No": "M_NO",
    "Whisker Matcha": "M_R5.1",
    "PURspresso": "M_R5.2", 
    "Catnip Tea": "M_R5.3",
    "WHAT DID YOU SAY?": "M_R6"
  };
  
  // Get option identifiers based on image key
  const imageToOptionMap = {
    "M_R1.1": "1", // Pardon?
    "M_R1.2": "2", // Huh
    "M_R1.3": "3", // Meow..?
    "M_R2.1": "translate", // Translate Meowish (disabled)
    "M_R2.2": "french", // French
    "M_R2.3": "english", // English (disabled)
    "M_R3.1": "forhere", // For here
    "M_R3.2": "drink", // A drink
    "M_YES": "yes", // Yes
    "M_NO": "no", // No
    "M_R5.1": "matcha", // Whisker Matcha
    "M_R5.2": "purspresso", // PURspresso
    "M_R5.3": "catnip", // Catnip Tea
    "M_R6": "whatsay", // WHAT DID YOU SAY?
    "M_R6.Blank": "textbox" // Type box
  };
  
  // Process each response option
  for (let i = 0; i < responseOptions.length; i++) {
    const optionText = responseOptions[i];
    
    // Determine image key
    let imageKey;
    
    if (optionText.startsWith("*make a type box")) {
      imageKey = state === "pete" ? "P_R4.Blank" : "M_R6.Blank";
    } else {
      imageKey = responseImages[optionText] ? optionText : textToImageMap[optionText];
    }
    
    if (imageKey && responseImages[imageKey]) {
      const originalWidth = responseImages[imageKey].width;
      const originalHeight = responseImages[imageKey].height;
      
      const imgHeight = Math.min(maxOptionHeight, height * 0.18);
      const imgWidth = (imgHeight / originalHeight) * originalWidth;
      
      optionDetails.push({
        imageKey: imageKey,
        width: imgWidth,
        height: imgHeight,
        option: imageToOptionMap[imageKey] || "1", // Default to "1" if not found
        isTextInput: imageKey === "P_R4.Blank" || imageKey === "M_R6.Blank",
        index: i,
        x: 0, // Will be set later
        y: 0  // Will be set later
      });
    }
  }
  
  // If no valid options, return
  if (optionDetails.length === 0) return;
  
  // Calculate positions for options
  const optionHeight = optionDetails[0].height;
  const optionWidth = optionDetails[0].width;
  const startX = blankRightEdge + (remainingSpace / 2) - (optionWidth / 2);
  
  // Define slot positions
  const slot3Y = height - bottomMargin - optionHeight;
  const slot2Y = slot3Y - optionHeight - optionSpacing;
  const slot1Y = slot2Y - optionHeight - optionSpacing;
  const slotPositions = [slot1Y, slot2Y, slot3Y];
  
  // Determine which slots to use based on number of options
  const slotsMap = [
    [],            // 0 options
    [2],           // 1 option
    [1, 2],        // 2 options
    [0, 1, 2]      // 3 options
  ];
  
  const slotsToUse = slotsMap[optionDetails.length] || [];
  
  // Draw each option in its slot and store positions
  for (let i = 0; i < optionDetails.length; i++) {
    if (i >= slotsToUse.length) break;
    
    const slotIndex = slotsToUse[i];
    const slotY = slotPositions[slotIndex];
    const opt = optionDetails[i];
    
    // Store position for click detection
    opt.x = startX;
    opt.y = slotY;

    // Draw the option image
    image(
      responseImages[opt.imageKey],
      opt.x,
      opt.y,
      opt.width,
      opt.height
    );

    // If this is a text input option, draw the text input field on top
    if (opt.isTextInput) {
      drawTextInputOnBlank(opt.x, opt.y, opt.width, opt.height);
    }
  }

// HTML setup script tags:
// <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
// <script src="coffee_shop_game.js"></script>
