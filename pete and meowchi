// Coffee Shop Interactive Story
// A game where the player selects a barista and follows a branching dialogue path

// Global variables
let state = "selection"; // start with barista selection
let selectedBarista = "";
let currentQuestion = "";
let responseOptions = [];
let showBlankImage = false;
let responseImages = {};
let yourName = "";
let userInput = "";
let maxCharacters = 10;
let checkmarkVisible = false;
let displayTimer = 0;
let timerStarted = false;
let showOptions = false;
let repeatCount = 0;
let isTypingActive = false; // Flag to track if typing is active
let cursorPosition = 0; // Track cursor position within text
let lastCursorBlink = 0; // For cursor blinking
let cursorVisible = true; // For cursor blinking
const CURSOR_BLINK_RATE = 500; // Blink every 500ms
let pixellariFont; // Variable to store the Pixellari font

// Text selection variables
let selectionMode = 'none'; // 'none', 'word', 'all'
let selectionStart = -1;
let selectionEnd = -1;
let selectionInProgress = false; // Track if user is currently dragging to select text
let dragStartPos = -1; // Starting position for drag selection

// Time variables
const ORIGINAL_PETE_ORDER_TIME = 0.2;
let peteOrderTime = ORIGINAL_PETE_ORDER_TIME; // seconds for initial order question
let drinkOrderTime = 1; // seconds for drink order question
let rejectionTime = 4; // seconds for rejection message

// Meowchi sequence variables
let meowchiBackground, meowchiQ1Image, meowchiBlankConfusedImage;
let meowchiQ3Image, meowchiQ4Image, meowchiQ5_1Image, meowchiQ5_2Image;
let meowchiQ6Image, meowchiQ7_1Image, meowchiQ7_2Image, meowchiQ7_3Image, meowchiQ8Image;
let meowishSequenceActive = false;
let meowOrderTime = 2; // Time for meowchi order questions (seconds)
let frenchOrderTime = 2; // Time for French questions (seconds)

// Additional mapping for Meowchi response options
const meowchiResponseImages = {};

// Image and background variables (will be populated in preload)
let tableBackground, peteBackground, peteQ1Image, peteBlankImage, peteQ3R2Image, peteQ3Image, 
    peteQ5_1Image, peteQ5_2Image, peteQ6Image, blankInputImage, checkmarkImage;
let baristaSelectionBackground; // Background for barista selection screen

// Image loading handling function
function loadGameImage(path, fallbackColor) {
  return loadImage(path,
    () => console.log(`${path} loaded successfully`),
    (err) => {
      console.error(`Failed to load ${path}:`, err);
      const img = createImage(400, 100);
      img.loadPixels();
      for (let i = 0; i < img.width; i++) {
        for (let j = 0; j < img.height; j++) {
          img.set(i, j, color(fallbackColor));
        }
      }
      img.updatePixels();
      return img;
    }
  );
}

// Helper function to ensure consistent image dimensions
function getImagePlacement() {
  const bottomMargin = height * 0.02;
  const imgWidth = width * 0.52;
  const imgHeight = width * 0.31;
  const imgX = width * 0.02;
  const imgY = height - imgHeight - bottomMargin;
  return { x: imgX, y: imgY, width: imgWidth, height: imgHeight };
}

// Preload function to load all necessary assets
function preload() {
  try {
    // Load font
    pixellariFont = loadFont('Pixellari.ttf');
    
    // Load table background (placeholder)
    tableBackground = loadImage('https://placehold.co/800x600');
    
    // Load barista selection background
    baristaSelectionBackground = loadGameImage('BG_baristas.png', [200, 200, 220]);
    
    // Load Pete's background image
    peteBackground = loadGameImage('BG_pete.png', [220, 180, 140]);
    
    // Load Pete's dialogue images
    peteQ1Image = loadGameImage('P_Q1.png', [255, 200, 200]);
    peteBlankImage = loadGameImage('P_Blank.png', [200, 200, 255]);
    peteQ3R2Image = loadGameImage('P_Q3.R2.png', [255, 150, 150]);
    peteQ3Image = loadGameImage('P_Q3.png', [200, 255, 200]);
    peteQ5_1Image = loadGameImage('P_Q5.1.png', [220, 200, 255]); // Confused face
    peteQ5_2Image = loadGameImage('P_Q5.2.png', [255, 150, 150]); // Angry face YOUR NAME?!!!
    peteQ6Image = loadGameImage('P_Q6.png', [200, 220, 255]); // Tired face with drink
    
    // Load blank image for text input
    blankInputImage = loadGameImage('P_R4.Blank.png', [240, 240, 255]);
    checkmarkImage = loadGameImage('check.png', [100, 255, 100]);
    
    // Load response images
    const imageKeys = ['P_R1.1', 'R_NO', 'R_YES', 'P_R3.1', 'P_R3.2', 'P_R3.3', 'P_R4.2'];
    const fallbackColors = [
      [220, 220, 255], [255, 220, 220], [220, 255, 220], 
      [255, 220, 220], [220, 255, 220], [220, 220, 255], [200, 255, 255]
    ];
    
    // Load all response images
    for (let i = 0; i < imageKeys.length; i++) {
      responseImages[imageKeys[i]] = loadGameImage(`${imageKeys[i]}.png`, fallbackColors[i]);
    }
    
    // Add the blank response image to responseImages collection
    responseImages['P_R4.Blank'] = blankInputImage;
    
    // Load Meowchi's background image
    meowchiBackground = loadGameImage('BG_meowchi.png', [220, 180, 220]);
    
    // Load Meowchi's dialogue images
    meowchiQ1Image = loadGameImage('M_Q1.png', [255, 200, 255]);
    meowchiBlankConfusedImage = loadGameImage('M_Blank.confused.png', [240, 240, 255]);
    meowchiQ3Image = loadGameImage('M_Q3.png', [200, 255, 255]);
    meowchiQ4Image = loadGameImage('M_Q4.png', [255, 200, 220]);
    meowchiQ5_1Image = loadGameImage('M_Q5.1.png', [220, 220, 255]);
    meowchiQ5_2Image = loadGameImage('M_Q5.2.png', [255, 220, 220]);
    meowchiQ6Image = loadGameImage('M_Q6.png', [200, 255, 200]); // Placeholder for video
    meowchiQ7_1Image = loadGameImage('M_Q7.1.png', [220, 255, 220]);
    meowchiQ7_2Image = loadGameImage('M_Q7.2.png', [255, 220, 255]);
    meowchiQ7_3Image = loadGameImage('M_Q7.3.png', [220, 220, 255]);
    meowchiQ8Image = loadGameImage('M_Q8.png', [200, 255, 200]);
    
    // Load Meowchi response images
    const meowchiImageKeys = [
      'M_R1.1', 'M_R1.2', 'M_R1.3', 
      'M_R2.1', 'M_R2.2', 'M_R2.3',
      'M_R3.1', 'M_R3.2',
      'M_R5.1', 'M_R5.2', 'M_R5.3',
      'M_R6', 'M_YES', 'M_NO'
    ];
    
    const meowchiFallbackColors = [
      [255, 220, 255], [220, 255, 255], [255, 255, 220],
      [220, 220, 255], [255, 220, 220], [220, 255, 220],
      [255, 220, 255], [220, 255, 255],
      [255, 220, 220], [220, 255, 220], [220, 220, 255],
      [255, 200, 200], [220, 255, 220], [255, 220, 220]
    ];
    
    // Load all Meowchi response images
    for (let i = 0; i < meowchiImageKeys.length; i++) {
      meowchiResponseImages[meowchiImageKeys[i]] = loadGameImage(
        `${meowchiImageKeys[i]}.png`, 
        meowchiFallbackColors[i]
      );
    }
    
    // Add the Meowchi blank response image (reuse Pete's for now)
    meowchiResponseImages['M_R6.Blank'] = blankInputImage;
    
  } catch (e) {
    console.error('Error loading images:', e);
  }
}

// Setup function to initialize the canvas and game settings
function setup() {
  try {
    // Calculate canvas dimensions with correct aspect ratio
    const targetWidth = 1280;
    const aspectRatio = 16/9;
    createCanvas(targetWidth, targetWidth / aspectRatio);
    textAlign(CENTER, CENTER);
    textSize(height * 0.02);
    
    // Use default font as fallback if Pixellari doesn't load properly
    if (!pixellariFont) {
      console.warn("Pixellari font not loaded, using default font instead");
    }
  } catch (e) {
    console.error('Error in setup:', e);
  }
}

// Main draw function to render different game states
function draw() {
  try {
    // Only use default background for states other than pete and meowchi
    if (state !== "pete" && state !== "meowchi") {
      background(220);
    }
    
    switch(state) {
      case "selection":
        drawBaristaSelection();
        showBlankImage = false;
        break;
      case "pete":
        drawPeteScene();
        break;
      case "meowchi":
        drawMeowchiDialogue();
        break;
      case "table":
        drawTable();
        showBlankImage = false;
        break;
      default:
        state = "selection";
        showBlankImage = false;
        break;
    }
  } catch (e) {
    console.error('Error in draw:', e);
    background(255, 0, 0);
    fill(255);
    text('An error occurred. Please check console.', width/2, height/2);
  }
}

// Draw the barista selection screen
function drawBaristaSelection() {
  // Use the barista selection background image
  if (baristaSelectionBackground) {
    image(baristaSelectionBackground, 0, 0, width, height);
  } else {
    // Fallback if image doesn't load
    background(240);
  }
  
  fill(0);
  textSize(width / 30);
  text("Pick a barista", width/2, height/8);
  
  const buttonWidth = width/5;
  const buttonHeight = height/6;
  const positions = [
    { x: width/4, y: height/2, label: "Pete" },
    { x: 3*width/4, y: height/2, label: "Meowchi" }
  ];
  
  // Draw both buttons
  for (const pos of positions) {
    fill(220);
    rect(pos.x - buttonWidth/2, pos.y - buttonHeight/2, buttonWidth, buttonHeight, 15);
    fill(0);
    text(pos.label, pos.x, pos.y);
  }
}

// Draw the Pete dialogue scene
function drawPeteScene() {
  // Draw the Pete background image for all parts of the Pete sequence
  if (peteBackground) {
    // Draw background to fill the entire canvas
    image(peteBackground, 0, 0, width, height);
  }
  
  // Handle image selection: blank background or dialogue
  if (showBlankImage && peteBlankImage) {
    const placement = getImagePlacement();
    image(peteBlankImage, placement.x, placement.y, placement.width, placement.height);
  }
  drawPeteDialogue();
}

// Render Pete's dialogue and manage dialogue progression
function drawPeteDialogue() {
  if (currentQuestion && !showOptions) {
    if (!timerStarted) {
      displayTimer = millis();
      timerStarted = true;
    }
    
    // Map questions to images and draw appropriately
    const questionImageMap = {
      "Can I take your order please?": peteQ1Image,
      "Okay thenâ€¦NEXT CUSTOMER!": peteQ3R2Image,
      "What can I get you?": peteQ3Image,
      "Ya! What â€¦â€¦..?": peteBlankImage, // Using blank image for now, would be video
      "YOUR NAME?!!!": peteQ5_2Image,
      "here's your drink.": peteQ6Image
    };
    
    // Handle special case for name confirmation (Q5.1)
    if (currentQuestion.includes("ok then") && !currentQuestion.includes("here's your drink")) {
      const placement = getImagePlacement();
      image(peteQ5_1Image, placement.x, placement.y, placement.width, placement.height);
      
      // Display the entered name on top of the image in green with a question mark in black
      if (pixellariFont) {
        textFont(pixellariFont);
      }
      
      // Adjust text size to exactly 27% of option height
      const maxOptionHeight = height * 0.18;
      const fontSize = maxOptionHeight * 0.27;
      
      // Position further to the left (11% of image width) and keep vertical position
      const textX = placement.x + placement.width * 0.11;
      const textY = placement.y + placement.height * 0.62;
      
      textSize(fontSize);
      textAlign(LEFT, CENTER);
      
      // Calculate the total width of name and question mark
      const nameWidth = textWidth(yourName);
      const questionMarkWidth = textWidth("?");
      
      // Draw the name in the specified green (#80C242)
      fill('#80C242');
      text(yourName, textX, textY);
      
      // Draw the question mark in black, immediately after the name with slight spacing
      fill(0); // Black color for question mark
      text("?", textX + nameWidth + (fontSize * 0.1), textY);
      
      // Reset text settings
      textAlign(CENTER, CENTER);
      textSize(height * 0.02);
      textFont('sans-serif');
    }
    // Handle special case for final drink delivery (Q6)
    else if (currentQuestion.includes("here's your drink")) {
      const placement = getImagePlacement();
      image(peteQ6Image, placement.x, placement.y, placement.width, placement.height);
      
      // Display the entered name on top of the image in green followed by a black comma
      if (pixellariFont) {
        textFont(pixellariFont);
      }
      
      // Use the same formatting as in Q5.1
      const maxOptionHeight = height * 0.18;
      const fontSize = maxOptionHeight * 0.27;
      const textX = placement.x + placement.width * 0.11;
      const textY = placement.y + placement.height * 0.62;
      
      textSize(fontSize);
      textAlign(LEFT, CENTER);
      
      // Calculate the width of the name for positioning the comma
      const nameWidth = textWidth(yourName);
      
      // Draw the name in the specified green (#80C242)
      fill('#80C242');
      text(yourName, textX, textY);
      
      // Draw the comma in black, immediately after the name with slight spacing
      fill(0); // Black color for comma
      text(",", textX + nameWidth + (fontSize * 0.05), textY);
      
      // Reset text settings
      textAlign(CENTER, CENTER);
      textSize(height * 0.02);
      textFont('sans-serif');
    }
    else if (questionImageMap[currentQuestion]) {
      // Use consistent image placement
      const placement = getImagePlacement();
      image(questionImageMap[currentQuestion], placement.x, placement.y, placement.width, placement.height);
    } else {
      // For other questions, display text
      fill(255);
      rect(width/2 - 300, 50, 600, 100, 20);
      fill(0);
      text(currentQuestion, width/2, 100);
    }
    
    // Determine display time based on question type
    let displayTime = 2000; // Default
    
    if (state === "pete") {
      if (currentQuestion === "Can I take your order please?") {
        displayTime = peteOrderTime * 1000;
      } else if (currentQuestion === "What can I get you?" || currentQuestion === "Ya! What â€¦â€¦..?") {
        displayTime = drinkOrderTime * 1000; 
      } else if (currentQuestion.includes("NEXT CUSTOMER")) {
        displayTime = rejectionTime * 1000;
      } else if (currentQuestion.includes("here's your drink")) {
        displayTime = drinkOrderTime * 5000; // 5 seconds for final drink delivery as specified
      } else if (currentQuestion.includes("ok then")) {
        displayTime = drinkOrderTime * 2000; // Short pause for name confirmation before moving to final screen
      }
    }
    
    // Check if time is up
    if (millis() - displayTimer > displayTime) {
      showOptions = true;
      timerStarted = false;
      
      // Handle special cases that transition to table state
      if (currentQuestion.includes("NEXT CUSTOMER") || currentQuestion.includes("here's your drink")) {
        state = "table";
        showOptions = false;
        currentQuestion = "";
        responseOptions = [];
      }
    }
  }
  
  // Show response options when needed
  if (showOptions) {
    drawResponseOptions();
  }
}

// Render response options for Pete's dialogue
function drawResponseOptions() {
  if (responseOptions.length === 0) return;

  const blankImagePlacement = getImagePlacement();
  const maxOptionHeight = height * 0.18;
  const blankRightEdge = blankImagePlacement.x + blankImagePlacement.width;
  const remainingSpace = width - blankRightEdge;
  const optionSpacing = height * 0.02;
  const bottomMargin = optionSpacing;
  
  // Process options to get their details (image keys, dimensions)
  let optionDetails = [];
  
  // Map text descriptions to image keys
  const textToImageMap = {
    "P_R1.1": "P_R1.1",
    "1. Can you repeat that please?": "P_R1.1",
    "No?": "R_NO",
    "3. No?": "R_NO",
    "Yea?": "R_YES",
    "2. Yea?": "R_YES",
    "1. Slow matcha?": "P_R3.1",
    "2. Bamboo tea?": "P_R3.2",
    "3. Black Eye espresso?": "P_R3.3",
    "I didn't catch that": "P_R4.2",
    "I didn't catch that, can you repeat?": "P_R4.2",
    "P_R4.2": "P_R4.2",
    "*make a type box": "P_R4.Blank"
  };
  
  // Get option identifiers based on image key
  const imageToOptionMap = {
    "P_R1.1": "1",
    "P_R3.1": "1", 
    "R_YES": "2",
    "P_R3.2": "2",
    "R_NO": "3",
    "P_R3.3": "3",
    "P_R4.2": "repeat",
    "P_R4.Blank": "textbox"
  };
  
  // Process each response option
  for (let i = 0; i < responseOptions.length; i++) {
    const optionText = responseOptions[i];
    
    // Determine image key
    let imageKey;
    
    if (optionText.startsWith("*make a type box")) {
      imageKey = "P_R4.Blank";
    } else {
      imageKey = responseImages[optionText] ? optionText : textToImageMap[optionText];
    }
    
    if (imageKey && responseImages[imageKey]) {
      const originalWidth = responseImages[imageKey].width;
      const originalHeight = responseImages[imageKey].height;
      
      const imgHeight = Math.min(maxOptionHeight, height * 0.18);
      const imgWidth = (imgHeight / originalHeight) * originalWidth;
      
      optionDetails.push({
        imageKey: imageKey,
        width: imgWidth,
        height: imgHeight,
        option: imageToOptionMap[imageKey] || "1", // Default to "1" if not found
        isTextInput: imageKey === "P_R4.Blank",
        index: i,
        x: 0, // Will be set later
        y: 0  // Will be set later
      });
    }
  }
  
  // If no valid options, return
  if (optionDetails.length === 0) return;
  
  // Calculate positions for options
  const optionHeight = optionDetails[0].height;
  const optionWidth = optionDetails[0].width;
  const startX = blankRightEdge + (remainingSpace / 2) - (optionWidth / 2);
  
  // Define slot positions
  const slot3Y = height - bottomMargin - optionHeight;
  const slot2Y = slot3Y - optionHeight - optionSpacing;
  const slot1Y = slot2Y - optionHeight - optionSpacing;
  const slotPositions = [slot1Y, slot2Y, slot3Y];
  
  // Determine which slots to use based on number of options
  const slotsMap = [
    [],            // 0 options
    [2],           // 1 option
    [1, 2],        // 2 options
    [0, 1, 2]      // 3 options
  ];
  
  const slotsToUse = slotsMap[optionDetails.length] || [];
  
  // Draw each option in its slot and store positions
  for (let i = 0; i < optionDetails.length; i++) {
    if (i >= slotsToUse.length) break;
    
    const slotIndex = slotsToUse[i];
    const slotY = slotPositions[slotIndex];
    const opt = optionDetails[i];
    
    // Store position for click detection
    opt.x = startX;
    opt.y = slotY;

    // Draw the option image
    image(
      responseImages[opt.imageKey],
      opt.x,
      opt.y,
      opt.width,
      opt.height
    );

    // If this is a text input option, draw the text input field on top
    if (opt.isTextInput) {
      drawTextInputOnBlank(opt.x, opt.y, opt.width, opt.height);
    }
  }
}

// Draw Meowchi's dialogue
function drawMeowchiDialogue() {
  // Draw the Meowchi background
  if (meowchiBackground) {
    image(meowchiBackground, 0, 0, width, height);
  } else {
    background(200, 220, 255); // Fallback color
  }
  
  // Handle Meowchi's dialogue sequence - always draw the current question
  if (currentQuestion) {
    if (!timerStarted) {
      displayTimer = millis();
      timerStarted = true;
    }
    
    // Map questions to images and draw appropriately
    const questionImageMap = {
      "[In meowish] meow meow me-meow meow?": meowchiQ1Image,
      "Que voulez-vous boire ?": meowchiQ3Image,
      "D'accord.. Voulez-vous un verre?": meowchiQ4Image,
      "Oh d'accord alorsâ€¦": meowchiQ5_1Image,
      "Quelle boisson veux-tu?": meowchiQ5_2Image,
      "Compris. Puis-je avoir ton n-BLENDERRRR": meowchiQ6Image,
      "MEOWCHI_Q7_1": meowchiQ7_1Image, // Use a consistent key for Q7.1
      "â€¦ votre nom?": meowchiQ7_2Image,
      "MEOWCHI_Q7_3": meowchiQ7_3Image, // Use a consistent key for Q7.3
      "MEOWCHI_Q8": meowchiQ8Image // Use a consistent key for Q8
    };
    
    // First, always draw the question/dialogue image - this is different from Pete's sequence
    // Handle special case for name confirmation (Q7.3)
    if (currentQuestion === "MEOWCHI_Q7_3") {
      const placement = getImagePlacement();
      image(meowchiQ7_3Image, placement.x, placement.y, placement.width, placement.height);
      
      // Display the entered name on top of the image
      if (pixellariFont) {
        textFont(pixellariFont);
      }
      
      const maxOptionHeight = height * 0.18;
      const fontSize = maxOptionHeight * 0.27;
      
      // Use the same positioning as Pete's sequence (11% from left)
      const textX = placement.x + placement.width * 0.11;
      const textY = placement.y + placement.height * 0.62;
      
      textSize(fontSize);
      textAlign(LEFT, CENTER);
      
      // Draw the name in Meowchi's color (#b166aa)
      fill('#b166aa');
      text(yourName, textX, textY);
      
      // Reset text settings
      textAlign(CENTER, CENTER);
      textSize(height * 0.02);
      textFont('sans-serif');
    }
    // Handle special case for final drink delivery (Q8)
    else if (currentQuestion === "MEOWCHI_Q8") {
      const placement = getImagePlacement();
      image(meowchiQ8Image, placement.x, placement.y, placement.width, placement.height);
      
      // Display the entered name on top of the image
      if (pixellariFont) {
        textFont(pixellariFont);
      }
      
      const maxOptionHeight = height * 0.18;
      const fontSize = maxOptionHeight * 0.27;
      
      // Use the same positioning as Pete's sequence (11% from left)
      const textX = placement.x + placement.width * 0.11;
      const textY = placement.y + placement.height * 0.62;
      
      textSize(fontSize);
      textAlign(LEFT, CENTER);
      
      // Draw the name in Meowchi's color (#b166aa)
      fill('#b166aa');
      text(yourName, textX, textY);
      
      // Reset text settings
      textAlign(CENTER, CENTER);
      textSize(height * 0.02);
      textFont('sans-serif');
    }
    // Handle special case for name question (Q7.1)
    else if (currentQuestion === "MEOWCHI_Q7_1") {
      const placement = getImagePlacement();
      image(meowchiQ7_1Image, placement.x, placement.y, placement.width, placement.height);
      
      // Display the entered name on top of the image
      if (pixellariFont) {
        textFont(pixellariFont);
      }
      
      const maxOptionHeight = height * 0.18;
      const fontSize = maxOptionHeight * 0.27;
      
      // Use the same positioning as Pete's sequence (11% from left)
      const textX = placement.x + placement.width * 0.11;
      const textY = placement.y + placement.height * 0.62;
      
      textSize(fontSize);
      textAlign(LEFT, CENTER);
      
      // Draw the name in Meowchi's color (#b166aa)
      fill('#b166aa');
      text(yourName, textX, textY);
      
      // Calculate width for question mark positioning
      const nameWidth = textWidth(yourName);
      
      // Draw the question mark in black, same as Pete's sequence
      fill(0); // Black color for question mark
      text("?", textX + nameWidth + (fontSize * 0.1), textY);
      
      // Reset text settings
      textAlign(CENTER, CENTER);
      textSize(height * 0.02);
      textFont('sans-serif');
    }
    else if (meowishSequenceActive && currentQuestion === "[In meowish] meow meow me-meow meow?") {
      // Show the confused face first, then the meowish dialogue again
      const placement = getImagePlacement();
      
      // Show confused face for 1 second, then show meowish dialogue again
      if (millis() - displayTimer < 1000) {
        image(meowchiBlankConfusedImage, placement.x, placement.y, placement.width, placement.height);
      } else {
        image(meowchiQ1Image, placement.x, placement.y, placement.width, placement.height);
      }
    }
    else if (questionImageMap[currentQuestion]) {
      // Use consistent image placement
      const placement = getImagePlacement();
      image(questionImageMap[currentQuestion], placement.x, placement.y, placement.width, placement.height);
    } else {
      // For other questions, display text
      fill(255);
      rect(width/2 - 300, 50, 600, 100, 20);
      fill(0);
      text(currentQuestion, width/2, 100);
    }
    
    // Only check for timer if options aren't showing yet
    if (!showOptions) {
      // Determine display time based on question type
      let displayTime = 2000; // Default
      
      if (state === "meowchi") {
        if (currentQuestion === "[In meowish] meow meow me-meow meow?") {
          if (meowishSequenceActive) {
            // Add extra time for the confused face transition
            displayTime = meowOrderTime * 1000 + 1000;
          } else {
            displayTime = meowOrderTime * 1000;
          }
        } else if (currentQuestion.includes("Que voulez-vous") || 
                   currentQuestion.includes("Quelle boisson")) {
          displayTime = frenchOrderTime * 1000; 
        } else if (currentQuestion.includes("Oh d'accord alors")) {
          displayTime = 3000; // 3 seconds for rejection message as specified
        } else if (currentQuestion.includes("votre boisson est prÃªte")) {
          displayTime = 4000; // 4 seconds for final drink message
        } else if (currentQuestion.includes("d'accord") && !currentQuestion.includes("Oh")) {
          displayTime = 2000; // Short pause for name confirmation
        }
      }
      
      // Check if time is up to display options
      if (millis() - displayTimer > displayTime) {
        showOptions = true;
        
        // Handle special cases that transition to table state
        if (currentQuestion.includes("Oh d'accord alors") || 
            currentQuestion.includes("votre boisson est prÃªte")) {
          state = "table";
          showOptions = false;
          currentQuestion = "";
          responseOptions = [];
        }
      }
    }
  }
  
  // Show response options when needed - drawn on top of the questions
  if (showOptions) {
    drawMeowchiResponseOptions();
  }
}

// Draw Meowchi's response options
function drawMeowchiResponseOptions() {
  if (responseOptions.length === 0) return;

  const blankImagePlacement = getImagePlacement();
  const maxOptionHeight = height * 0.18;
  const blankRightEdge = blankImagePlacement.x + blankImagePlacement.width;
  const remainingSpace = width - blankRightEdge;
  const optionSpacing = height * 0.02;
  const bottomMargin = optionSpacing;
  
  // Process options to get their details (image keys, dimensions)
  let optionDetails = [];
  
  // Map text descriptions to image keys
  const textToImageMap = {
    "Pardon?": "M_R1.1",
    "Huh": "M_R1.2",
    "Meow..?": "M_R1.3",
    "Translate Meowish": "M_R2.1",
    "French": "M_R2.2",
    "English": "M_R2.3",
    "For here": "M_R3.1",
    "A drink": "M_R3.2",
    "Yes": "M_YES",
    "No": "M_NO",
    "Whisker Matcha": "M_R5.1",
    "PURspresso": "M_R5.2",
    "Catnip Tea": "M_R5.3",
    "WHAT DID YOU SAY?": "M_R6",
    "*make a type box": "M_R6.Blank"
  };
  
  // Get option identifiers based on image key
  const imageToOptionMap = {
    "M_R1.1": "1",
    "M_R1.2": "2", 
    "M_R1.3": "3",
    "M_R2.1": "translate",
    "M_R2.2": "french",
    "M_R2.3": "english",
    "M_R3.1": "1",
    "M_R3.2": "2",
    "M_YES": "yes",
    "M_NO": "no",
    "M_R5.1": "1",
    "M_R5.2": "2",
    "M_R5.3": "3",
    "M_R6": "what",
    "M_R6.Blank": "textbox"
  };
  
  // Process each response option
  for (let i = 0; i < responseOptions.length; i++) {
    const optionText = responseOptions[i];
    
    // Determine image key
    let imageKey;
    
    if (optionText.startsWith("*make a type box")) {
      imageKey = "M_R6.Blank";
    } else {
      imageKey = meowchiResponseImages[optionText] ? optionText : textToImageMap[optionText];
    }
    
    if (imageKey && (meowchiResponseImages[imageKey] || responseImages[imageKey])) {
      // Get the image from either collection
      const imageObj = meowchiResponseImages[imageKey] || responseImages[imageKey];
      const originalWidth = imageObj.width;
      const originalHeight = imageObj.height;
      
      const imgHeight = Math.min(maxOptionHeight, height * 0.18);
      const imgWidth = (imgHeight / originalHeight) * originalWidth;
      
      optionDetails.push({
        imageKey: imageKey,
        width: imgWidth,
        height: imgHeight,
        option: imageToOptionMap[imageKey] || "1", // Default to "1" if not found
        isTextInput: imageKey === "M_R6.Blank",
        selectable: imageKey !== "M_R2.1" && imageKey !== "M_R2.3", // Track which options can't be selected
        index: i,
        x: 0, // Will be set later
        y: 0  // Will be set later
      });
    }
  }
  
  // If no valid options, return
  if (optionDetails.length === 0) return;
  
  // Calculate positions for options
  const optionHeight = optionDetails[0].height;
  const optionWidth = optionDetails[0].width;
  const startX = blankRightEdge + (remainingSpace / 2) - (optionWidth / 2);
  
  // Define slot positions
  const slot3Y = height - bottomMargin - optionHeight;
  const slot2Y = slot3Y - optionHeight - optionSpacing;
  const slot1Y = slot2Y - optionHeight - optionSpacing;
  const slotPositions = [slot1Y, slot2Y, slot3Y];
  
  // Determine which slots to use based on number of options
  const slotsMap = [
    [],            // 0 options
    [2],           // 1 option
    [1, 2],        // 2 options
    [0, 1, 2]      // 3 options
  ];
  
  const slotsToUse = slotsMap[optionDetails.length] || [];
  
  // Draw each option in its slot and store positions
  for (let i = 0; i < optionDetails.length; i++) {
    if (i >= slotsToUse.length) break;
    
    const slotIndex = slotsToUse[i];
    const slotY = slotPositions[slotIndex];
    const opt = optionDetails[i];
    
    // Store position for click detection
    opt.x = startX;
    opt.y = slotY;

    // Draw the option image
    const imageObj = meowchiResponseImages[opt.imageKey] || responseImages[opt.imageKey];
    image(
      imageObj,
      opt.x,
      opt.y,
      opt.width,
      opt.height
    );

    // No grey overlay for non-selectable options - removed per request
    // They will still be non-clickable through the mousePressed logic

    // If this is a text input option, draw the text input field on top
    if (opt.isTextInput) {
      drawTextInputOnBlank(opt.x, opt.y, opt.width, opt.height);
    }
  }
}

// Helper function to check if input only contains spaces
function containsOnlySpaces(str) {
  return str.trim().length === 0;
}

// Draw text input on blank image
function drawTextInputOnBlank(x, y, width, height) {
  // Position text further to the left within the image (about 15% from left edge)
  const textX = x + width * 0.15;
  // Position text slightly higher than center (45% from top instead of 50%)
  const textY = y + height * 0.45;

  // Use an even larger text size for better visibility
  const textFontSize = height * 0.25; // Increased from 0.2 to 0.25
  // Use consistent colors for text and caret
  const placeholderCol = color(150, 150, 150); // Gray color for placeholder
  const userTextCol = color('#414042'); // Specific color for user input
  const caretCol = color(100, 100, 100); // Slightly darker gray for caret

  // Handle blinking cursor
  if (millis() - lastCursorBlink > CURSOR_BLINK_RATE) {
    cursorVisible = !cursorVisible;
    lastCursorBlink = millis();
  }

  // Draw the text (either placeholder or typed input)
  textAlign(LEFT, CENTER); // Left alignment

  // Set the Pixellari font if it's loaded
  if (pixellariFont) {
    textFont(pixellariFont);
  }

  if (!isTypingActive && userInput === "") {
    // Show placeholder when not typing and no input
    textSize(textFontSize);
    fill(placeholderCol); // Gray for placeholder
    text("type response", textX, textY);
  } else {
    // When typing or with input
    textSize(textFontSize);

    if (userInput.length > 0) {
      // Use specific color for user input text
      fill(userTextCol); 
      
      // Add selection highlight if applicable
      if (selectionMode !== 'none') {
        const beforeSelectedText = userInput.substring(0, selectionStart);
        const selectedText = userInput.substring(selectionStart, selectionEnd);
        
        const beforeWidth = textWidth(beforeSelectedText);
        const selectedWidth = textWidth(selectedText);

        // Draw selection rectangle
        fill(200, 200, 255, 100); // Light blue with transparency
        noStroke();
        rect(textX + beforeWidth, textY - textFontSize/2, selectedWidth, textFontSize);
        
        // Reset text color for input
        fill(userTextCol);
      }
      
      text(userInput, textX, textY);
      
      // Calculate where to draw the cursor
      let beforeCursor = userInput.substring(0, cursorPosition);
      let cursorX = textX + textWidth(beforeCursor);
      
      // Draw blinking cursor at current position
      if (isTypingActive && cursorVisible) {
        stroke(caretCol);
        strokeWeight(2);
        line(cursorX, textY - textFontSize/2, cursorX, textY + textFontSize/2);
        noStroke();
      }
    } else {
      // Just show blinking cursor for empty input when focused
      if (isTypingActive && cursorVisible) {
        stroke(caretCol);
        strokeWeight(2);
        line(textX, textY - textFontSize/2, textX, textY + textFontSize/2);
        noStroke();
      }
    }
  }

  // Reset text size and font
  textSize(height * 0.025);
  textFont('sans-serif'); // Reset to default font

  // Show checkmark if input meets criteria (at least 1 character and not only spaces and not exceeding max)
  const hasValidInput = userInput.length > 0 && !containsOnlySpaces(userInput) && userInput.length <= maxCharacters;
  checkmarkVisible = hasValidInput;

  if (checkmarkVisible) {
    // Place checkmark inside the image on the right side (about 85% from left edge)
    const checkSize = height * 0.5; // Increased from 0.4 to 0.5
    const checkX = x + width * 0.85 - checkSize/2; // Inside image, right side
    const checkY = y + (height - checkSize)/2 - height * 0.05; // Slightly up

    // Use checkmark image if available
    if (checkmarkImage) {
      image(checkmarkImage, checkX, checkY, checkSize, checkSize);
    } else {
      // Fallback drawn checkmark
      fill(0, 200, 0);
      rect(checkX, checkY, checkSize, checkSize, 10);
      fill(255);
      textSize(checkSize * 0.6);
      text("âœ“", checkX + checkSize/2, checkY + checkSize/2);
      textSize(height * 0.025); // Reset text size
    }
  }
}

// Handle mouse press events
function mousePressed() {
try {
  // Handle barista selection
  if (state === "selection") {
    const buttonWidth = width/5;
    const buttonHeight = height/6;
    
    // Define the buttons and their actions
    const buttons = [
      {
        x: width/4, 
        y: height/2, 
        action: () => {
          selectedBarista = "pete";
          state = "pete";
          startPeteDialogue();
        }
      },
      {
        x: 3*width/4, 
        y: height/2, 
        action: () => {
          selectedBarista = "meowchi";
          state = "meowchi";
          startMeowchiDialogue();
        }
      }
    ];
    
    // Check if any button was clicked
    for (const button of buttons) {
      if (mouseX > button.x - buttonWidth/2 && mouseX < button.x + buttonWidth/2 && 
          mouseY > button.y - buttonHeight/2 && mouseY < button.y + buttonHeight/2) {
        button.action();
        return;
      }
    }
  }

  // Handle response options for Pete dialogue
  else if (showOptions && state === "pete") {
    // First, process response options to identify what's on screen
    const blankImagePlacement = getImagePlacement();
    const maxOptionHeight = height * 0.18;
    const blankRightEdge = blankImagePlacement.x + blankImagePlacement.width;
    const remainingSpace = width - blankRightEdge;
    const optionSpacing = height * 0.02;
    const bottomMargin = optionSpacing;
    
    // Process options to get their details
    let optionDetails = [];
    
    // Map text descriptions to image keys
    const textToImageMap = {
      "P_R1.1": "P_R1.1",
      "R_NO": "R_NO",
      "R_YES": "R_YES",
      "P_R3.1": "P_R3.1",
      "P_R3.2": "P_R3.2",
      "P_R3.3": "P_R3.3",
      "P_R4.2": "P_R4.2",
      "*make a type box": "P_R4.Blank"
    };
    
    // Get option identifiers based on image key
    const imageToOptionMap = {
      "P_R1.1": "1",
      "P_R3.1": "1", 
      "R_YES": "2",
      "P_R3.2": "2",
      "R_NO": "3",
      "P_R3.3": "3",
      "P_R4.2": "repeat",
      "P_R4.Blank": "textbox"
    };
    
    // Process each response option
    for (let i = 0; i < responseOptions.length; i++) {
      const optionText = responseOptions[i];
      
      // Determine image key
      let imageKey;
      
      if (optionText.startsWith("*make a type box")) {
        imageKey = "P_R4.Blank";
      } else {
        imageKey = responseImages[optionText] ? optionText : textToImageMap[optionText];
      }
      
      if (imageKey && responseImages[imageKey]) {
        const originalWidth = responseImages[imageKey].width;
        const originalHeight = responseImages[imageKey].height;
        
        const imgHeight = Math.min(maxOptionHeight, height * 0.18);
        const imgWidth = (imgHeight / originalHeight) * originalWidth;
        
        optionDetails.push({
          imageKey: imageKey,
          width: imgWidth,
          height: imgHeight,
          option: imageToOptionMap[imageKey] || "1", // Default to "1" if not found
          isTextInput: imageKey === "P_R4.Blank",
          index: i,
          x: 0, // Will be set later
          y: 0  // Will be set later
        });
      }
    }
    
    // If no valid options, return
    if (optionDetails.length === 0) return;
    
    // Calculate positions for options
    const optionHeight = optionDetails[0].height;
    const optionWidth = optionDetails[0].width;
    const startX = blankRightEdge + (remainingSpace / 2) - (optionWidth / 2);
    
    // Define slot positions
    const slot3Y = height - bottomMargin - optionHeight;
    const slot2Y = slot3Y - optionHeight - optionSpacing;
    const slot1Y = slot2Y - optionHeight - optionSpacing;
    const slotPositions = [slot1Y, slot2Y, slot3Y];
    
    // Determine which slots to use based on number of options
    const slotsMap = [
      [],            // 0 options
      [2],           // 1 option
      [1, 2],        // 2 options
      [0, 1, 2]      // 3 options
    ];
    
    const slotsToUse = slotsMap[optionDetails.length] || [];
    
    // Static variables to track click timing
    if (typeof mousePressed.lastClickTime === 'undefined') {
      mousePressed.lastClickTime = 0;
      mousePressed.clickCount = 0;
    }

    // Check for click on checkmark first (if visible)
    if (checkmarkVisible) {
      // Find the text input option
      const textInputOption = optionDetails.find(opt => opt.isTextInput);
      if (textInputOption) {
        const textInputIndex = optionDetails.indexOf(textInputOption);
        if (textInputIndex < slotsToUse.length) {
          const slotIndex = slotsToUse[textInputIndex];
          const slotY = slotPositions[slotIndex];
          
          // Calculate checkmark position to match visual position inside the image
          const checkSize = optionHeight * 0.5; 
          const checkX = startX + optionWidth * 0.85 - checkSize/2; 
          const checkY = slotY + (optionHeight - checkSize)/2 - optionHeight * 0.05;
          
          // Check if clicked on checkmark
          if (mouseX > checkX && mouseX < checkX + checkSize && 
              mouseY > checkY && mouseY < checkY + checkSize) {
            // Handle checkmark click
            yourName = userInput;
            userInput = "";
            isTypingActive = false;
            handlePeteResponse("checkmark");
            return;
          }
        }
      }
    }
    
    // Check for click on any option
    for (let i = 0; i < optionDetails.length; i++) {
      if (i >= slotsToUse.length) break;
      
      const slotIndex = slotsToUse[i];
      const slotY = slotPositions[slotIndex];
      const opt = optionDetails[i];
      
      // Store position for click detection
      opt.x = startX;
      opt.y = slotY;
      
      // Check if clicked within this option's bounds
      if (mouseX > opt.x && mouseX < opt.x + opt.width &&
          mouseY > opt.y && mouseY < opt.y + opt.height) {
    
        // Special handling for text input option
        if (opt.isTextInput) {
          // Activate typing and handle text cursor positioning
          isTypingActive = true;
          
          // Calculate text-related dimensions
          const textX = startX + optionWidth * 0.15;
          const textY = slotY + optionHeight * 0.45;
          const textFontSize = optionHeight * 0.25;
          
          // Use the same font settings as in drawTextInputOnBlank
          if (pixellariFont) {
            textFont(pixellariFont);
          }
          textSize(textFontSize);
          
          // Determine character position based on mouse click
          if (mouseX > textX && mouseX < startX + optionWidth * 0.85) {
            // Determine the character position by measuring text widths
            let prevWidth = 0;
            cursorPosition = 0;
            
            for (let i = 0; i <= userInput.length; i++) {
              const currText = userInput.substring(0, i);
              const currWidth = textWidth(currText);
              
              if (mouseX < textX + currWidth) {
                // Use the closer of the two positions
                cursorPosition = (mouseX - (textX + prevWidth) < (textX + currWidth) - mouseX) 
                  ? Math.max(0, i - 1) 
                  : i;
                break;
              }
              
              prevWidth = currWidth;
              
              // If we've reached the end, place cursor at the end
              if (i === userInput.length) {
                cursorPosition = userInput.length;
              }
            }
          }
          
          // Reset text settings
          textSize(height * 0.025);
          textFont('sans-serif');
          
          // Initialize drag selection
          dragStartPos = cursorPosition;
          selectionInProgress = false;  // Not dragging yet, just clicking
          
          // Handle multiple clicks for selection
          const currentTime = millis();
          const DOUBLE_CLICK_DELAY = 300;
          const TRIPLE_CLICK_DELAY = 500;
          
          // Check time since last click
          if (currentTime - mousePressed.lastClickTime <= TRIPLE_CLICK_DELAY) {
            mousePressed.clickCount++;
            
            if (mousePressed.clickCount === 2) {
              // Double-click: Select word
              selectionMode = 'word';
              
              // Find word boundaries
              let start = cursorPosition;
              let end = cursorPosition;
              
              // Move start back to word start
              while (start > 0 && userInput[start-1] !== ' ') {
                start--;
              }
              
              // Move end forward to word end
              while (end < userInput.length && userInput[end] !== ' ') {
                end++;
              }
              
              selectionStart = start;
              selectionEnd = end;
            } else if (mousePressed.clickCount === 3) {
              // Triple-click: Select all
              selectionMode = 'all';
              selectionStart = 0;
              selectionEnd = userInput.length;
            }
          } else {
            // If it's been too long since last click, reset counter
            mousePressed.clickCount = 1;
            
            // Single click: Clear selection unless we're starting a new drag
            if (selectionMode !== 'none') {
              selectionMode = 'none';
              selectionStart = -1;
              selectionEnd = -1;
            }
          }

          // Update last click time
          mousePressed.lastClickTime = currentTime;
          
          return;
        }
        
        // For regular options, deactivate typing and handle the response
        isTypingActive = false;
        
        // Clear text input if clicking on the "I didn't catch that" option (P_R4.2)
        if (opt.imageKey === "P_R4.2") {
          userInput = "";
          cursorPosition = 0;
          
          // Reset selection state
          selectionMode = 'none';
          selectionStart = -1;
          selectionEnd = -1;
        }
        
        handlePeteResponse(opt.option);
        return;
      }
    }
  }

  // Handle response options for Meowchi dialogue
  else if (showOptions && state === "meowchi") {
    // Process response options for Meowchi dialogue
    const blankImagePlacement = getImagePlacement();
    const maxOptionHeight = height * 0.18;
    const blankRightEdge = blankImagePlacement.x + blankImagePlacement.width;
    const remainingSpace = width - blankRightEdge;
    const optionSpacing = height * 0.02;
    const bottomMargin = optionSpacing;
    
    // Process options to get their details
    let optionDetails = [];
    
    // Map text descriptions to image keys
    const textToImageMap = {
      "Pardon?": "M_R1.1",
      "Huh": "M_R1.2",
      "Meow..?": "M_R1.3",
      "Translate Meowish": "M_R2.1",
      "French": "M_R2.2",
      "English": "M_R2.3",
      "For here": "M_R3.1",
      "A drink": "M_R3.2",
      "Yes": "M_YES",
      "No": "M_NO",
      "Whisker Matcha": "M_R5.1",
      "PURspresso": "M_R5.2",
      "Catnip Tea": "M_R5.3",
      "WHAT DID YOU SAY?": "M_R6",
      "*make a type box": "M_R6.Blank"
    };
    
    // Get option identifiers based on image key
    const imageToOptionMap = {
      "M_R1.1": "1",
      "M_R1.2": "2", 
      "M_R1.3": "3",
      "M_R2.1": "translate",
      "M_R2.2": "french",
      "M_R2.3": "english",
      "M_R3.1": "1",
      "M_R3.2": "2",
      "M_YES": "yes",
      "M_NO": "no",
      "M_R5.1": "1",
      "M_R5.2": "2",
      "M_R5.3": "3",
      "M_R6": "what",
      "M_R6.Blank": "textbox"
    };
    
    // Process each response option
    for (let i = 0; i < responseOptions.length; i++) {
      const optionText = responseOptions[i];
      
      // Determine image key
      let imageKey;
      
      if (optionText.startsWith("*make a type box")) {
        imageKey = "M_R6.Blank";
      } else {
        imageKey = meowchiResponseImages[optionText] ? optionText : textToImageMap[optionText];
      }
      
      if (imageKey && (meowchiResponseImages[imageKey] || responseImages[imageKey])) {
        const imageObj = meowchiResponseImages[imageKey] || responseImages[imageKey];
        const originalWidth = imageObj.width;
        const originalHeight = imageObj.height;
        
        const imgHeight = Math.min(maxOptionHeight, height * 0.18);
        const imgWidth = (imgHeight / originalHeight) * originalWidth;
        
        optionDetails.push({
          imageKey: imageKey,
          width: imgWidth,
          height: imgHeight,
          option: imageToOptionMap[imageKey] || "1",
          isTextInput: imageKey === "M_R6.Blank",
          selectable: imageKey !== "M_R2.1" && imageKey !== "M_R2.3", // Make some options unselectable
          index: i,
          x: 0,
          y: 0
        });
      }
    }
    
    // If no valid options, return
    if (optionDetails.length === 0) return;
    
    // Calculate positions for options
    const optionHeight = optionDetails[0].height;
    const optionWidth = optionDetails[0].width;
    const startX = blankRightEdge + (remainingSpace / 2) - (optionWidth / 2);
    
    // Define slot positions
    const slot3Y = height - bottomMargin - optionHeight;
    const slot2Y = slot3Y - optionHeight - optionSpacing;
    const slot1Y = slot2Y - optionHeight - optionSpacing;
    const slotPositions = [slot1Y, slot2Y, slot3Y];
    
    // Determine which slots to use based on number of options
    const slotsMap = [
      [],            // 0 options
      [2],           // 1 option
      [1, 2],        // 2 options
      [0, 1, 2]      // 3 options
    ];
    
    const slotsToUse = slotsMap[optionDetails.length] || [];
    
    // Check for click on checkmark first (if visible)
    if (checkmarkVisible) {
      // Find the text input option
      const textInputOption = optionDetails.find(opt => opt.isTextInput);
      if (textInputOption) {
        const textInputIndex = optionDetails.indexOf(textInputOption);
        if (textInputIndex < slotsToUse.length) {
          const slotIndex = slotsToUse[textInputIndex];
          const slotY = slotPositions[slotIndex];
          
          // Calculate checkmark position
          const checkSize = optionHeight * 0.5; 
          const checkX = startX + optionWidth * 0.85 - checkSize/2; 
          const checkY = slotY + (optionHeight - checkSize)/2 - optionHeight * 0.05;
          
          // Check if clicked on checkmark
          if (mouseX > checkX && mouseX < checkX + checkSize && 
              mouseY > checkY && mouseY < checkY + checkSize) {
            // Handle checkmark click
            yourName = userInput;
            userInput = "";
            isTypingActive = false;
            handleMeowchiResponse("checkmark");
            return;
          }
        }
      }
    }
    
    // Check for click on any option
    for (let i = 0; i < optionDetails.length; i++) {
      if (i >= slotsToUse.length) break;
      
      const slotIndex = slotsToUse[i];
      const slotY = slotPositions[slotIndex];
      const opt = optionDetails[i];
      
      // Store position for click detection
      opt.x = startX;
      opt.y = slotY;
      
      // Check if clicked within this option's bounds
      if (mouseX > opt.x && mouseX < opt.x + opt.width &&
          mouseY > opt.y && mouseY < opt.y + opt.height) {
        
        // Skip if option is not selectable
        if (!opt.selectable) {
          return;
        }
        
        // Special handling for text input option
        if (opt.isTextInput) {
          isTypingActive = true;
          
          // Position cursor same as in Pete sequence
          const textX = startX + optionWidth * 0.15;
          const textY = slotY + optionHeight * 0.45;
          const textFontSize = optionHeight * 0.25;
          
          if (pixellariFont) {
            textFont(pixellariFont);
          }
          textSize(textFontSize);
          
          // Determine character position based on mouse click
          if (mouseX > textX && mouseX < startX + optionWidth * 0.85) {
            // Determine the character position by measuring text widths
            let prevWidth = 0;
            cursorPosition = 0;
            
            for (let i = 0; i <= userInput.length; i++) {
              const currText = userInput.substring(0, i);
              const currWidth = textWidth(currText);
              
              if (mouseX < textX + currWidth) {
                // Use the closer of the two positions
                cursorPosition = (mouseX - (textX + prevWidth) < (textX + currWidth) - mouseX) 
                  ? Math.max(0, i - 1) 
                  : i;
                break;
              }
              
              prevWidth = currWidth;
              
              // If we've reached the end, place cursor at the end
              if (i === userInput.length) {
                cursorPosition = userInput.length;
              }
            }
          }
          
          // Reset text settings
          textSize(height * 0.025);
          textFont('sans-serif');
          
          // Initialize drag selection
          dragStartPos = cursorPosition;
          selectionInProgress = false;  // Not dragging yet, just clicking
          
          // Handle multiple clicks for selection
          const currentTime = millis();
          const DOUBLE_CLICK_DELAY = 300;
          const TRIPLE_CLICK_DELAY = 500;
          
          // Check time since last click
          if (currentTime - mousePressed.lastClickTime <= TRIPLE_CLICK_DELAY) {
            mousePressed.clickCount++;
            
            if (mousePressed.clickCount === 2) {
              // Double-click: Select word
              selectionMode = 'word';
              
              // Find word boundaries
              let start = cursorPosition;
              let end = cursorPosition;
              
              // Move start back to word start
              while (start > 0 && userInput[start-1] !== ' ') {
                start--;
              }
              
              // Move end forward to word end
              while (end < userInput.length && userInput[end] !== ' ') {
                end++;
              }
              
              selectionStart = start;
              selectionEnd = end;
            } else if (mousePressed.clickCount === 3) {
              // Triple-click: Select all
              selectionMode = 'all';
              selectionStart = 0;
              selectionEnd = userInput.length;
            }
          } else {
            // If it's been too long since last click, reset counter
            mousePressed.clickCount = 1;
            
            // Single click: Clear selection unless we're starting a new drag
            if (selectionMode !== 'none') {
              selectionMode = 'none';
              selectionStart = -1;
              selectionEnd = -1;
            }
          }

          // Update last click time
          mousePressed.lastClickTime = currentTime;
          
          return;
        }
        
        // For regular options, deactivate typing and handle the response
        isTypingActive = false;
        
        // Clear text input if needed
        if (opt.option === "what") {
          userInput = "";
          cursorPosition = 0;
          
          // Reset selection state
          selectionMode = 'none';
          selectionStart = -1;
          selectionEnd = -1;
        }
        
        handleMeowchiResponse(opt.option);
        return;
      }
    }
  }

  // If we get here, user clicked somewhere else
  isTypingActive = false;

  // Handle return from table
  if (state === "table" && millis() - displayTimer > 3000) {
    if (mouseX > width/2 - 100 && mouseX < width/2 + 100 && 
        mouseY > height - 80 && mouseY < height - 30) {
      state = "selection";
      timerStarted = false;
    }
  }
} catch (e) {
  console.error('Error in mousePressed:', e);
}
}

// Handle mouse dragging for text selection
function mouseDragged() {
if (isTypingActive && dragStartPos !== -1) {
  // Set selection mode to active
  selectionInProgress = true;

  // Get text dimensions
  const optionFound = false;
  let textX = 0;
  let textY = 0;
  let optionWidth = 0;
  let textFontSize = 0;

  // Find the text input option to get its position
  for (let i = 0; i < responseOptions.length; i++) {
    if (responseOptions[i].startsWith("*make a type box")) {
      // We found the text input option, now calculate its position
      const blankImagePlacement = getImagePlacement();
      const maxOptionHeight = height * 0.18;
      const blankRightEdge = blankImagePlacement.x + blankImagePlacement.width;
      const remainingSpace = width - blankRightEdge;
      
      // Calculate option dimensions
      const originalWidth = responseImages['P_R4.Blank'].width;
      const originalHeight = responseImages['P_R4.Blank'].height;
      const imgHeight = Math.min(maxOptionHeight, height * 0.18);
      const imgWidth = (imgHeight / originalHeight) * originalWidth;
      
      // Calculate option position
      const optionSpacing = height * 0.02;
      const bottomMargin = optionSpacing;
      const startX = blankRightEdge + (remainingSpace / 2) - (imgWidth / 2);
      
      // Set text position values for calculations
      textX = startX + imgWidth * 0.15;
      optionWidth = imgWidth;
      textFontSize = imgHeight * 0.25;
      
      break;
    }
  }

  if (textX === 0) return; // If we didn't find the text input option

  // Calculate cursor position based on mouse position
  if (pixellariFont) {
    textFont(pixellariFont);
  }
  textSize(textFontSize);

  // Find cursor position at mouse point
  let newPosition = 0;

  // If mouse is before text area, set to start
  if (mouseX <= textX) {
    newPosition = 0;
  } 
  // If mouse is past text area, set to end
  else if (mouseX >= textX + textWidth(userInput)) {
    newPosition = userInput.length;
  }
  // Otherwise, find closest character
  else {
    for (let i = 0; i <= userInput.length; i++) {
      const currText = userInput.substring(0, i);
      const currWidth = textWidth(currText);
      
      if (mouseX < textX + currWidth) {
        // Choose the closer position
        newPosition = (mouseX - (textX + textWidth(userInput.substring(0, i-1))) < 
                     (textX + currWidth) - mouseX) 
          ? Math.max(0, i - 1) 
          : i;
        break;
      }
      
      // If we've reached the end, place cursor at the end
      if (i === userInput.length) {
        newPosition = userInput.length;
      }
    }
  }

  // Set cursor to new position
  cursorPosition = newPosition;

  // Update selection
  selectionMode = 'drag';
  selectionStart = Math.min(dragStartPos, newPosition);
  selectionEnd = Math.max(dragStartPos, newPosition);

  // Reset text settings
  textSize(height * 0.025);
  textFont('sans-serif');
}
}

// Handle mouse release event
function mouseReleased() {
  // If we were selecting text, finalize the selection
  if (isTypingActive && selectionInProgress) {
    selectionInProgress = false;

    // If start and end are the same, clear selection
    if (selectionStart === selectionEnd) {
      selectionMode = 'none';
      selectionStart = -1;
      selectionEnd = -1;
    }
  }

  // Reset drag start position
  dragStartPos = -1;
}

// Handle key typed events for text input
function keyTyped() {
  // Only handle typing when typing is active
  if (isTypingActive) {
    // Get the text width of the current input with the Pixellari font
    if (pixellariFont) {
      textFont(pixellariFont);
      textSize(height * 0.25); // Match the increased font size used in drawTextInputOnBlank
    }

    // If there's a selection, replace it
    if (selectionMode !== 'none') {
      // Delete selected text and insert new character
      userInput = userInput.substring(0, selectionStart) + key + userInput.substring(selectionEnd);
      cursorPosition = selectionStart + 1; // Move cursor after inserted character
      
      // Reset selection
      selectionMode = 'none';
      selectionStart = -1;
      selectionEnd = -1;
    } else {
      // Only check character count, not width, to ensure users can type all 10 characters
      if (userInput.length < maxCharacters) {
        // Insert character at cursor position
        userInput = userInput.substring(0, cursorPosition) + key + userInput.substring(cursorPosition);
        cursorPosition++; // Move cursor after inserted character
      }
    }

    // Reset the font to default
    textFont('sans-serif');

    return false; // Prevent default behavior
  }
  return true; // Allow default behavior
}

// Handle complex key press events
function keyPressed() {
  if (!isTypingActive) return true;

  // Handle Enter key for form submission when checkmark is visible
  if (keyCode === ENTER && checkmarkVisible) {
    yourName = userInput;
    userInput = "";
    isTypingActive = false;
    if (state === "pete") {
      handlePeteResponse("checkmark");
    } else if (state === "meowchi") {
      handleMeowchiResponse("checkmark");
    }
    return false;
  }

  // Handle backspace or delete with selection
  if (keyCode === BACKSPACE || keyCode === 46) { // BACKSPACE or DELETE
    if (selectionMode !== 'none') {
      // Delete selected text
      userInput = userInput.substring(0, selectionStart) + userInput.substring(selectionEnd);
      cursorPosition = selectionStart;
      
      // Reset selection
      selectionMode = 'none';
      selectionStart = -1;
      selectionEnd = -1;
      
      return false;
    }

    // Existing backspace/delete logic for no selection
    if (keyCode === BACKSPACE) {
      if (cursorPosition > 0) {
        userInput = userInput.substring(0, cursorPosition - 1) + userInput.substring(cursorPosition);
        cursorPosition--;
      }
      return false;
    }

    if (keyCode === 46) { // DELETE key
      if (cursorPosition < userInput.length) {
        userInput = userInput.substring(0, cursorPosition) + userInput.substring(cursorPosition + 1);
      }
      return false;
    }
  }

  // Handle left arrow (keyCode 37)
  if (keyCode === 37) { // LEFT_ARROW
    if (cursorPosition > 0) {
      cursorPosition--;
      
      // If shift is held, modify selection
      if (keyIsDown(SHIFT)) {
        if (selectionMode === 'none') {
          // Start a new selection
          selectionMode = 'drag';
          dragStartPos = cursorPosition + 1;
          selectionStart = cursorPosition;
          selectionEnd = dragStartPos;
        } else {
          // Update existing selection
          if (cursorPosition < dragStartPos) {
            selectionStart = cursorPosition;
            selectionEnd = dragStartPos;
          } else {
            selectionStart = dragStartPos;
            selectionEnd = cursorPosition;
          }
        }
      } else {
        // Reset selection on arrow key press without shift
        selectionMode = 'none';
        selectionStart = -1;
        selectionEnd = -1;
      }
    }
    return false;
  }

  // Handle right arrow (keyCode 39)
  if (keyCode === 39) { // RIGHT_ARROW
    if (cursorPosition < userInput.length) {
      cursorPosition++;
      
      // If shift is held, modify selection
      if (keyIsDown(SHIFT)) {
        if (selectionMode === 'none') {
          // Start a new selection
          selectionMode = 'drag';
          dragStartPos = cursorPosition - 1;
          selectionStart = dragStartPos;
          selectionEnd = cursorPosition;
        } else {
          // Update existing selection
          if (cursorPosition > dragStartPos) {
            selectionStart = dragStartPos;
            selectionEnd = cursorPosition;
          } else {
            selectionStart = cursorPosition;
            selectionEnd = dragStartPos;
          }
        }
      } else {
        // Reset selection on arrow key press without shift
        selectionMode = 'none';
        selectionStart = -1;
        selectionEnd = -1;
      }
    }
    return false;
  }

  // Handle Ctrl+A to select all (keyCode 65 is 'A')
  if (keyCode === 65 && keyIsDown(CONTROL)) {
    selectionMode = 'all';
    selectionStart = 0;
    selectionEnd = userInput.length;
    cursorPosition = userInput.length;
    return false;
  }

  // Handle home key (keyCode 36)
  if (keyCode === 36) { // HOME
    cursorPosition = 0;

    // If shift is held, modify selection
    if (keyIsDown(SHIFT)) {
      if (selectionMode === 'none') {
        selectionMode = 'drag';
        dragStartPos = userInput.length;
      }
      selectionStart = 0;
      selectionEnd = dragStartPos;
    } else {
      // Reset selection
      selectionMode = 'none';
      selectionStart = -1;
      selectionEnd = -1;
    }
    return false;
  }

  // Handle end key (keyCode 35)
  if (keyCode === 35) { // END
    cursorPosition = userInput.length;

    // If shift is held, modify selection
    if (keyIsDown(SHIFT)) {
      if (selectionMode === 'none') {
        selectionMode = 'drag';
        dragStartPos = 0;
      }
      selectionStart = dragStartPos;
      selectionEnd = userInput.length;
    } else {
      // Reset selection
      selectionMode = 'none';
      selectionStart = -1;
      selectionEnd = -1;
    }
    return false;
  }

  return true; // Allow default behavior for other keys
}

// Start Pete's dialogue sequence
function startPeteDialogue() {
  console.log("Starting Pete dialogue sequence");
  showBlankImage = true;
  isTypingActive = false;
  userInput = "";
  cursorPosition = 0;
  cursorVisible = true;
  lastCursorBlink = millis();

  // Reset selection
  selectionMode = 'none';
  selectionStart = -1;
  selectionEnd = -1;

  // Start with Q1 after a short delay
  setTimeout(() => {
    currentQuestion = "Can I take your order please?";
    responseOptions = ["P_R1.1"];
    showOptions = false;
    timerStarted = false;
    repeatCount = 0;
  }, 200);
}

// Handle Pete's dialogue responses
function handlePeteResponse(response) {
  showOptions = false;
  timerStarted = false;

  // Dialogue flow handling using a state machine approach
  const dialogueMap = {
    "Can I take your order please?": {
      // First interaction with only one option
      oneOption: () => {
        peteOrderTime += 0.2;
        currentQuestion = "Can I take your order please?";
        responseOptions = ["P_R1.1", "R_YES", "R_NO"];
      },
      // After showing multiple options
      "1": () => {
        repeatCount++;
        if (repeatCount >= 2) {
          currentQuestion = "Okay thenâ€¦NEXT CUSTOMER!";
          responseOptions = [];
          peteOrderTime = ORIGINAL_PETE_ORDER_TIME;
          repeatCount = 0;
        } else {
          peteOrderTime += 0.2;
          currentQuestion = "Can I take your order please?";
        }
      },
      "2": () => {
        repeatCount = 0;
        currentQuestion = "What can I get you?";
        responseOptions = ["P_R3.1", "P_R3.2", "P_R3.3"];
      },
      "3": () => {
        repeatCount = 0;
        currentQuestion = "Okay thenâ€¦NEXT CUSTOMER!";
        responseOptions = [];
        peteOrderTime = ORIGINAL_PETE_ORDER_TIME;
      }
    },
    "What can I get you?": {
      "1": () => {
        currentQuestion = "Ya! What â€¦â€¦..?";
        responseOptions = [
          "*make a type box",
          "P_R4.2"
        ];
      },
      "2": () => {
        currentQuestion = "Ya! What â€¦â€¦..?";
        responseOptions = [
          "*make a type box",
          "P_R4.2"
        ];
      },
      "3": () => {
        currentQuestion = "Ya! What â€¦â€¦..?";
        responseOptions = [
          "*make a type box",
          "P_R4.2"
        ];
      },
      default: () => {
        currentQuestion = "Ya! What â€¦â€¦..?";
        responseOptions = [
          "*make a type box",
          "P_R4.2"
        ];
      }
    },
    "Ya! What â€¦â€¦..?": {
      "checkmark": () => {
        // Save name and show confirmation (Q5.1)
        currentQuestion = `${yourName} ok then`;
        responseOptions = [];
        
        // After a short delay, transition to final drink delivery (Q6)
        setTimeout(() => {
          currentQuestion = `${yourName} here's your drink.`;
        }, 1500);
      },
      "repeat": () => {
        // If "I didn't catch that" is selected, show angry Pete (Q5.2)
        currentQuestion = "YOUR NAME?!!!";
        responseOptions = [
          "*make a type box"
        ];
        showBlankImage = true;
      },
      "textbox": () => {
        // This is now handled in mousePressed
        console.log("Activating text input");
        isTypingActive = true;
      }
    },
    "YOUR NAME?!!!": {
      "checkmark": () => {
        // After entering name in the angry Pete screen, go directly to final screen
        currentQuestion = `${yourName} here's your drink.`;
        responseOptions = [];
      },
      "textbox": () => {
        // This is now handled in mousePressed
        console.log("Activating text input");
        isTypingActive = true;
      }
    }
  };

  // Execute the appropriate dialogue flow
  if (dialogueMap[currentQuestion]) {
    if (responseOptions.length === 1 && dialogueMap[currentQuestion].oneOption) {
      dialogueMap[currentQuestion].oneOption();
    } else if (dialogueMap[currentQuestion][response]) {
      dialogueMap[currentQuestion][response]();
    } else if (dialogueMap[currentQuestion].default) {
      dialogueMap[currentQuestion].default();
    }
  }
}

// Start Meowchi's dialogue sequence
function startMeowchiDialogue() {
  console.log("Starting Meowchi dialogue sequence");
  showBlankImage = true;
  isTypingActive = false;
  userInput = "";
  cursorPosition = 0;
  cursorVisible = true;
  lastCursorBlink = millis();
  meowishSequenceActive = false;

  // Reset selection
  selectionMode = 'none';
  selectionStart = -1;
  selectionEnd = -1;

  // Start with Q1 after a short delay
  setTimeout(() => {
    currentQuestion = "[In meowish] meow meow me-meow meow?";
    responseOptions = ["Pardon?", "Huh", "Meow..?"];
    showOptions = false;
    timerStarted = false;
    displayTimer = 0; // Reset display timer to ensure proper timing
  }, 200);
}

// Handle Meowchi's dialogue responses
function handleMeowchiResponse(response) {
  showOptions = false;
  timerStarted = true; // Keep timer active for Meowchi's responses

  // For R1 responses, set the confused face state first
  if (currentQuestion === "[In meowish] meow meow me-meow meow?" && 
      (response === "1" || response === "2" || response === "3")) {
    console.log("Showing confused face");
    meowishSequenceActive = true;
    displayTimer = millis(); // Reset timer for the confused face transition
    
    // Set responses to show after the confused face
    setTimeout(() => {
      responseOptions = ["Translate Meowish", "French", "English"];
    }, 1000);
    
    return;
  }

  // Dialogue flow handling using a state machine approach
  const dialogueMap = {
    "[In meowish] meow meow me-meow meow?": {
      "1": () => { // Pardon?
        // Do nothing here - handled at the top of the function
      },
      "2": () => { // Huh
        // Do nothing here - handled at the top of the function
      },
      "3": () => { // Meow..?
        // Do nothing here - handled at the top of the function
      }
    },
    
    // French selection path
    "french": () => {
      meowishSequenceActive = false;
      currentQuestion = "Que voulez-vous boire ?";
      responseOptions = ["For here", "A drink"];
    },
    
    "Que voulez-vous boire ?": {
      "1": () => { // For here
        currentQuestion = "D'accord.. Voulez-vous un verre?";
        responseOptions = ["Yes", "No"];
      },
      "2": () => { // A drink
        currentQuestion = "D'accord.. Voulez-vous un verre?";
        responseOptions = ["Yes", "No"];
      }
    },
    
    "D'accord.. Voulez-vous un verre?": {
      "yes": () => {
        currentQuestion = "Quelle boisson veux-tu?";
        responseOptions = ["Whisker Matcha", "PURspresso", "Catnip Tea"];
      },
      "no": () => {
        currentQuestion = "Oh d'accord alorsâ€¦";
        responseOptions = [];
      }
    },
    
    "Quelle boisson veux-tu?": {
      "1": () => { // Whisker Matcha
        currentQuestion = "Compris. Puis-je avoir ton n-BLENDERRRR";
        responseOptions = [
          "*make a type box",
          "WHAT DID YOU SAY?"
        ];
      },
      "2": () => { // PURspresso
        currentQuestion = "Compris. Puis-je avoir ton n-BLENDERRRR";
        responseOptions = [
          "*make a type box",
          "WHAT DID YOU SAY?"
        ];
      },
      "3": () => { // Catnip Tea
        currentQuestion = "Compris. Puis-je avoir ton n-BLENDERRRR";
        responseOptions = [
          "*make a type box",
          "WHAT DID YOU SAY?"
        ];
      }
    },
    
    "Compris. Puis-je avoir ton n-BLENDERRRR": {
      "textbox": () => {
        // This is handled in mousePressed
        console.log("Activating text input");
        isTypingActive = true;
      },
      "what": () => {
        currentQuestion = "â€¦ votre nom?";
        responseOptions = [
          "*make a type box"
        ];
      },
      "checkmark": () => {
        // Save name and show confirmation
        currentQuestion = "MEOWCHI_Q7_1"; // Use consistent key instead of formatted string
        responseOptions = [];
        
        // After a short delay, transition to final name confirmation
        setTimeout(() => {
          currentQuestion = "MEOWCHI_Q7_3"; // Use consistent key
          
          // Then transition to final drink delivery
          setTimeout(() => {
            currentQuestion = "MEOWCHI_Q8"; // Use consistent key
          }, 2000);
        }, 2000);
      }
    },
    
    "â€¦ votre nom?": {
      "textbox": () => {
        // This is handled in mousePressed
        console.log("Activating text input");
        isTypingActive = true;
      },
      "checkmark": () => {
        // Save name and show final name confirmation
        currentQuestion = "MEOWCHI_Q7_3"; // Use consistent key
        responseOptions = [];
        
        // After a short delay, transition to final drink delivery
        setTimeout(() => {
          currentQuestion = "MEOWCHI_Q8"; // Use consistent key
        }, 2000);
      }
    }
  };

  // Execute the appropriate dialogue flow based on current state
  if (meowishSequenceActive && currentQuestion === "[In meowish] meow meow me-meow meow?") {
    // Special handling for the meowish repeated question with language selection
    if (response === "french") {
      dialogueMap["french"]();
    } else {
      // For unselectable options or translate option, just show options again
      showOptions = true;
    }
  } else if (dialogueMap[currentQuestion] && dialogueMap[currentQuestion][response]) {
    // Normal dialogue flow
    dialogueMap[currentQuestion][response]();
  } else if (typeof dialogueMap[response] === 'function') {
    // Handle direct response functions (like "french")
    dialogueMap[response]();
  }
}

// Render table scene
function drawTable() {
  // Draw table background or fallback
  if (tableBackground) {
    image(tableBackground, 0, 0, width, height);
  } else {
    background(200, 230, 200);
    text("At your table", width/2, height/2);
  }

  // Show return button after delay
  if (!timerStarted) {
    displayTimer = millis();
    timerStarted = true;
  }

  if (millis() - displayTimer > 3000) {
    fill(220);
    rect(width/2 - 100, height - 80, 200, 50, 10);
    fill(0);
    text("Return to selection", width/2, height - 55);
  }
}

// HTML setup script tags:
// <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
// <script src="coffee_shop_game.js"></script>
